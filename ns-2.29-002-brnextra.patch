diff -rupN ns-2.29/aodv/aodv.cc ns-2.29-click-scheduler/aodv/aodv.cc
--- ns-2.29/aodv/aodv.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/aodv/aodv.cc	2007-03-08 15:12:37.000000000 +0100
@@ -286,7 +286,7 @@ double total_latency = 0.0;
 */
 
 static void
-aodv_rt_failed_callback(Packet *p, void *arg) {
+aodv_rt_failed_callback(Packet *p, void *arg, int32_t retries) {
   ((AODV*) arg)->rt_ll_failed(p);
 }
 
diff -rupN ns-2.29/classifier/classifier-click.cc ns-2.29-click-scheduler/classifier/classifier-click.cc
--- ns-2.29/classifier/classifier-click.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/classifier/classifier-click.cc	2007-03-08 15:12:37.000000000 +0100
@@ -102,6 +102,15 @@ ClickClassifier::command(int argc, const
       }
       return TCL_OK;
     }
+    if (strcmp(argv[1], "halt") == 0) {
+      // runclick
+      if (clickinst_) {
+        simclick_simstate simstate;
+        simstate.curtime = GetSimTime();
+        simclick_click_kill(clickinst_,&simstate);
+      }
+      return TCL_OK;
+    }
   }
   else if (3 == argc) {
     if(strcmp(argv[1], "loadclick") == 0) {
@@ -212,6 +221,9 @@ ClickClassifier::~ClickClassifier() {
 
 int
 ClickClassifier::route(Packet* p) {
+
+  //fprintf(stderr,"ClickClassifier::route!!!\n");
+
   int result = 0;
   if (clickinst_) {
     unsigned char* data = NULL;
@@ -226,6 +238,11 @@ ClickClassifier::route(Packet* p) {
     int nssubtype = rhdr->subtype;
     int clicktype = GetClickPacketType(nssubtype);
     simpinfo.simtype = rhdr->ns_type;
+
+    // number of retries
+    simpinfo.retries = 0;
+    simpinfo.rx_power = p->txinfo_.RxPr;
+
     unsigned char* pdat = p->accessdata();
     data = new unsigned char[len];
     memcpy(data,pdat,len);
@@ -508,14 +525,14 @@ ClickClassifier::GetClickPacketType(int 
 
 
 void
-ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg) {
+ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg, int32_t retries) {
   // Hit the callback and then free the packet
-  ((ClickClassifier*)arg)->LinkLayerFailed(p);
+  ((ClickClassifier*)arg)->LinkLayerFailed(p, retries);
   Packet::free(p);
 }
 
 void
-ClickClassifier::LinkLayerFailed(Packet* p) {
+ClickClassifier::LinkLayerFailed(Packet* p, int32_t retries) {
   //fprintf(stderr,"XXX Lost a packet!!!\n");
   if (clickinst_) {
     unsigned char* data = NULL;
@@ -526,6 +543,10 @@ ClickClassifier::LinkLayerFailed(Packet*
     hdr_ip* iphdr = hdr_ip::access(p);
     simpinfo.id = chdr->uid();
     simpinfo.fid = iphdr->flowid();
+
+    // number of retries
+    simpinfo.retries = retries;
+
     hdr_raw* rhdr = hdr_raw::access(p);
     int nssubtype = rhdr->subtype;
     int clicktype = GetClickPacketType(nssubtype);
@@ -536,7 +557,7 @@ ClickClassifier::LinkLayerFailed(Packet*
     simstate.curtime = GetSimTime();
     //fprintf(stderr,"Sending packet up to click...\n");
     simclick_click_send(clickinst_,&simstate,ifid,clicktype,data,len,&simpinfo);
-    delete data;
+    delete[] data;
     data = 0;
   }
   else {
@@ -553,8 +574,6 @@ ClickClassifier::MakeRawPacket(int type,
    */
   hdr_raw* rhdr = hdr_raw::access(pkt);
   rhdr->subtype = GetNSSubtype(type);
-  unsigned char* pdat = pkt->accessdata();
-  memcpy(pdat,data,len);
 
   /*
    * Set some of the packet header stuff ns-2 wants
@@ -573,12 +592,6 @@ ClickClassifier::MakeRawPacket(int type,
   chdr->xmit_failure_ = LinkLayerFailedCallback;
   chdr->xmit_failure_data_ = (void*)this;
 
-  hdr_ip* iphdr = hdr_ip::access(pkt);
-  iphdr->flowid() = 0;
-  if (pinfo->fid >= 0) {
-    iphdr->flowid() = pinfo->fid;
-  }
-
   /*
    * A packet coming in from click on the kernel tap device is
    * considered to be going up into the node, on any other device
@@ -599,6 +612,12 @@ ClickClassifier::MakeRawPacket(int type,
     }
   }
 
+  // Got an IP packet? Must have come from click, and therefore
+  // the next hop is us.
+  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
+    chdr->next_hop() = nodeaddr_;
+  }
+
   // If we've got ethernet encapsulation, translate mac address
   // to ns address. Otherwise we're SOL.
   struct hdr_mac* mhdr = HDR_MAC(pkt);
@@ -621,11 +640,40 @@ ClickClassifier::MakeRawPacket(int type,
     mhdr->macDA_ = MAC_BROADCAST;
   }
 
-  // Got an IP packet? Must have come from click, and therefore
-  // the next hop is us.
-  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
-    chdr->next_hop() = nodeaddr_;
+  // Prepare ip header
+  hdr_ip* iphdr = hdr_ip::access(pkt);
+  iphdr->flowid() = 0;
+  if (pinfo->fid >= 0) {
+    iphdr->flowid() = pinfo->fid;
   }
+/*
+  click_ip* cip =  (click_ip*)data;
+  iphdr->saddr() = cip->ip_src;
+  iphdr->daddr() = cip->ip_dst;
+  iphdr->ttl()   = cip->ip_ttl;
+  
+  data += sizeof(click_ip);
+  len  -= sizeof(click_ip);
+
+  if (6 == cip->ip_p) { // TCP
+    hdr_tcp *tcph = hdr_tcp::access(pkt); // TCP header
+    hdr_flags *fh = hdr_flags::access(pkt); // flags (CWR, CE, bits)
+    click_tcp* ctcp = (click_tcp*) data;
+
+    iphdr->sport() = ctcp->th_sport;
+    iphdr->dport() = ctcp->th_dport;
+    tcph->seqno() = ctcp->th_seq;
+    tcph->hlen()  = ctcp->
+    tcph->ackno() = ctcp->th_ack;
+    tcph->flags() = ctcp->th_flags;
+    
+    data += sizeof(click_ip);
+    len  -= sizeof(click_ip);
+  }
+  //else if (17 == cip->ip_p) { // UDP
+*/
+  unsigned char* pdat = pkt->accessdata();
+  memcpy(pdat,data,len);
 
   return pkt;
 }
diff -rupN ns-2.29/classifier/classifier-click.h ns-2.29-click-scheduler/classifier/classifier-click.h
--- ns-2.29/classifier/classifier-click.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/classifier/classifier-click.h	2007-03-08 15:12:37.000000000 +0100
@@ -139,8 +139,8 @@ class ClickClassifier : public ExtClassi
   int GetNodeAddr(); /// ToNSTrace
   int IFReady(int ifid);
   simclick_click GetClickinst() { return clickinst_; }
-  static void LinkLayerFailedCallback(Packet* p, void* arg);
-  void LinkLayerFailed(Packet* p);
+  static void LinkLayerFailedCallback(Packet* p, void* arg, int32_t retries);
+  void LinkLayerFailed(Packet* p, int32_t retries);
   void trace(char* fmt, ...); /// ToNSTrace
   int GetNextPktID(); /// ToNSTrace
  protected:
diff -rupN ns-2.29/common/agent.cc ns-2.29-click-scheduler/common/agent.cc
--- ns-2.29/common/agent.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/common/agent.cc	2007-03-08 15:12:37.000000000 +0100
@@ -137,7 +137,7 @@ int Agent::command(int argc, const char*
 		} else if (strcmp(argv[1], "show-monitor") == 0) {
 			if ((traceName_ == 0) || (channel_ == 0))
 				return (TCL_OK);
-			monitorAgentTrace();
+      monitorAgentTrace();
 			return (TCL_OK);
 		} else if (strcmp(argv[1], "close") == 0) {
 			close();
@@ -474,15 +474,15 @@ Agent::toraw(Packet* p) {
 	struct hdr_ip* hip = HDR_IP(p);
 	struct hdr_cmn* hcmn = HDR_CMN(p);
 	struct hdr_raw* hraw = hdr_raw::access(p);
-	int packetlen = sizeof(click_ip) + hcmn->size_;
-	int paylen = hcmn->size_;
+	int packetlen = hcmn->size_;
+	int paylen = packetlen - sizeof(click_ip);
 	unsigned char* pdat = 0;
 
 	// build packet length
 	if (hcmn->ptype_ == PT_ACK || hcmn->ptype_ == PT_TCP)
-		packetlen += sizeof(click_tcp);
+		paylen -= sizeof(click_tcp);
 	else if (hcmn->ptype_ == PT_CBR)
-		packetlen += sizeof(click_udp);
+		paylen -= sizeof(click_udp);
 	else
 		return false;
 
@@ -534,7 +534,7 @@ Agent::toraw(Packet* p) {
 		tcp->th_flags = htcp->tcp_flags_;
 		if (hcmn->ptype_ == PT_ACK)
 			tcp->th_flags |= TH_ACK;
-		tcp->th_win = 0; /* XXX */
+		tcp->th_win = htons(htcp->window_);
 		tcp->th_urp = 0;
 		tcp->th_sum = 0;
 		uint16_t len = packetlen - sizeof(click_ip);
@@ -578,6 +578,7 @@ Agent::fromraw(Packet* p) {
 		htcp->tcp_flags_ = tcp->th_flags;
 		htcp->hlen_ = (ip->ip_hl << 2) + (tcp->th_off << 2);
 		hcmn->ptype_ = (tcp->th_flags & TH_ACK) ? PT_ACK : PT_TCP;
+    htcp->window_ = ntohl(tcp->th_win);
 		result = true;
 		break;
 	case IPPROTO_UDP:
@@ -585,6 +586,8 @@ Agent::fromraw(Packet* p) {
 		result = true;
 		break;
 	default:
+    hcmn->ptype_ = PT_NTYPE;
+    printf("ERROR: Agent::fromraw got packet with unknown type %d.", ip->ip_p);
 		result = false;
 		break;
 	}
diff -rupN ns-2.29/common/packet.h ns-2.29-click-scheduler/common/packet.h
--- ns-2.29/common/packet.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/common/packet.h	2007-03-08 15:12:37.000000000 +0100
@@ -270,7 +270,8 @@ public:
 		name_[PT_NTYPE]= "undefined";
 	}
 	const char* name(packet_t p) const { 
-		if ( p <= PT_NTYPE ) return name_[p];
+		if ( 0 <= p && p <= PT_NTYPE ) return name_[p];
+    printf("ERROR: p_info::name invalid packet type %d.", p);
 		return 0;
 	}
 	static bool data_packet(packet_t type) {
@@ -336,7 +337,7 @@ private:
 };
 
 //Monarch ext
-typedef void (*FailureCallback)(Packet *,void *);
+typedef void (*FailureCallback)(Packet *,void *, int32_t);
 
 class Packet : public Event {
 private:
@@ -620,6 +621,7 @@ inline Packet* Packet::copy() const
 	if (data_) 
 		p->data_ = data_->copy();
 	p->txinfo_.init(&txinfo_);
+  p->uid_ = this->uid_;
  
 	return (p);
 }
diff -rupN ns-2.29/common/scheduler.cc.orig ns-2.29-click-scheduler/common/scheduler.cc.orig
--- ns-2.29/common/scheduler.cc.orig	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/common/scheduler.cc.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1044 +0,0 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1994 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.73 2005/08/22 05:08:32 tomh Exp $
- */
-
-#ifndef lint
-static const char rcsid[] =
-    "@(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.cc,v 1.73 2005/08/22 05:08:32 tomh Exp $ (LBL)";
-#endif
-
-#include <stdlib.h>
-#include <limits.h>
-#include <math.h>
-
-#include "config.h"
-#include "scheduler.h"
-#include "packet.h"
-
-
-#ifdef MEMDEBUG_SIMULATIONS
-#include "mem-trace.h"
-#endif
-
-Scheduler* Scheduler::instance_;
-scheduler_uid_t Scheduler::uid_ = 1;
-
-// class AtEvent : public Event {
-// public:
-// 	char* proc_;
-// };
-
-Scheduler::Scheduler() : clock_(SCHED_START), halted_(0)
-{
-}
-
-Scheduler::~Scheduler(){
-	instance_ = NULL ;
-}
-
-/*
- * Schedule an event delay time units into the future.
- * The event will be dispatched to the specified handler.
- * We use a relative time to avoid the problem of scheduling
- * something in the past.
- *
- * Scheduler::schedule does a fair amount of error checking
- * because debugging problems when events are triggered
- * is much harder (because we've lost all context about who did
- * the scheduling).
- */
-void 
-Scheduler::schedule(Handler* h, Event* e, double delay)
-{
-	// handler should ALWAYS be set... if it's not, it's a bug in the caller
-	if (!h) {
-		fprintf(stderr,
-			"Scheduler: attempt to schedule an event with a NULL handler."
-			"  Don't DO that.\n");
-		abort();
-	};
-	
-	if (e->uid_ > 0) {
-		printf("Scheduler: Event UID not valid!\n\n");
-		abort();
-	}
-	
-	if (delay < 0) {
-		// You probably don't want to do this
-		// (it probably represents a bug in your simulation).
-		fprintf(stderr, 
-			"warning: ns Scheduler::schedule: scheduling event\n\t"
-			"with negative delay (%f) at time %f.\n", delay, clock_);
-	}
-
-	if (uid_ < 0) {
-		fprintf(stderr, "Scheduler: UID space exhausted!\n");
-		abort();
-	}
-	e->uid_ = uid_++;
-	e->handler_ = h;
-	double t = clock_ + delay;
-
-	e->time_ = t;
-	insert(e);
-}
-
-void
-Scheduler::run()
-{
-	instance_ = this;
-	Event *p;
-	/*
-	 * The order is significant: if halted_ is checked later,
-	 * event p could be lost when the simulator resumes.
-	 * Patch by Thomas Kaemer <Thomas.Kaemer@eas.iis.fhg.de>.
-	 */
-	while (!halted_ && (p = deque())) {
-		dispatch(p, p->time_);
-	}
-}
-
-/*
- * dispatch a single simulator event by setting the system
- * virtul clock to the event's timestamp and calling its handler.
- * Note that the event may have side effects of placing other items
- * in the scheduling queue
- */
-
-void
-Scheduler::dispatch(Event* p, double t)
-{
-	if (t < clock_) {
-		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
-		abort();
-	}
-
-	clock_ = t;
-	p->uid_ = -p->uid_;	// being dispatched
-	p->handler_->handle(p);	// dispatch
-}
-
-void
-Scheduler::dispatch(Event* p)
-{
-	dispatch(p, p->time_);
-}
-
-class AtEvent : public Event {
-public:
-	AtEvent() : proc_(0) {
-	}
-	~AtEvent() {
-		if (proc_) delete [] proc_;
-	}
-	char* proc_;
-};
-
-class AtHandler : public Handler {
-public:
-	void handle(Event* event);
-} at_handler;
-
-void 
-AtHandler::handle(Event* e)
-{
-	AtEvent* at = (AtEvent*)e;
-	Tcl::instance().eval(at->proc_);
-	delete at;
-}
-
-void
-Scheduler::reset()
-{
-	clock_ = SCHED_START;
-}
-
-int 
-Scheduler::command(int argc, const char*const* argv)
-{
-	Tcl& tcl = Tcl::instance();
-	if (instance_ == 0)
-		instance_ = this;
-	if (argc == 2) {
-		if (strcmp(argv[1], "run") == 0) {
-			/* set global to 0 before calling object reset methods */
-			reset();	// sets clock to zero
-			run();
-			return (TCL_OK);
-		} else if (strcmp(argv[1], "now") == 0) {
-			sprintf(tcl.buffer(), "%.17g", clock());
-			tcl.result(tcl.buffer());
-			return (TCL_OK);
-		} else if (strcmp(argv[1], "resume") == 0) {
-			halted_ = 0;
-			run();
-			return (TCL_OK);
-		} else if (strcmp(argv[1], "halt") == 0) {
-			halted_ = 1;
-			return (TCL_OK);
-
-		} else if (strcmp(argv[1], "clearMemTrace") == 0) {
-#ifdef MEMDEBUG_SIMULATIONS
-			extern MemTrace *globalMemTrace;
-			if (globalMemTrace)
-				globalMemTrace->diff("Sim.");
-#endif
-			return (TCL_OK);
-		} else if (strcmp(argv[1], "is-running") == 0) {
-			sprintf(tcl.buffer(), "%d", !halted_);
-			return (TCL_OK);
-		} else if (strcmp(argv[1], "dumpq") == 0) {
-			if (!halted_) {
-				fprintf(stderr, "Scheduler: dumpq only allowed while halted\n");
-				tcl.result("0");
-				return (TCL_ERROR);
-			}
-			dumpq();
-			return (TCL_OK);
-		}
-	} else if (argc == 3) {
-		if (strcmp(argv[1], "at") == 0 ||
-		    strcmp(argv[1], "cancel") == 0) {
-			Event* p = lookup(STRTOUID(argv[2]));
-			if (p != 0) {
-				/*XXX make sure it really is an atevent*/
-				cancel(p);
-				AtEvent* ae = (AtEvent*)p;
-				delete ae;
-			}
-		} else if (strcmp(argv[1], "at-now") == 0) {
-			const char* proc = argv[2];
-
-			// "at [$ns now]" may not work because of tcl's 
-			// string number resolution
-			AtEvent* e = new AtEvent;
-			int n = strlen(proc);
-			e->proc_ = new char[n + 1];
-			strcpy(e->proc_, proc);
-			schedule(&at_handler, e, 0);
-			sprintf(tcl.buffer(), UID_PRINTF_FORMAT, e->uid_);
-			tcl.result(tcl.buffer());
-		}
-		return (TCL_OK);
-	} else if (argc == 4) {
-		if (strcmp(argv[1], "at") == 0) {
-			/* t < 0 means relative time: delay = -t */
-			double delay, t = atof(argv[2]);
-			const char* proc = argv[3];
-
-			AtEvent* e = new AtEvent;
-			int n = strlen(proc);
-			e->proc_ = new char[n + 1];
-			strcpy(e->proc_, proc);
-			delay = (t < 0) ? -t : t - clock();
-			if (delay < 0) {
-				tcl.result("can't schedule command in past");
-				return (TCL_ERROR);
-			}
-			schedule(&at_handler, e, delay);
-			sprintf(tcl.buffer(), UID_PRINTF_FORMAT, e->uid_);
-			tcl.result(tcl.buffer());
-			return (TCL_OK);
-		}
-	}
-	return (TclObject::command(argc, argv));
-}
-
-void
-Scheduler::dumpq()
-{
-	Event *p;
-
-	printf("Contents of scheduler queue (events) [cur time: %f]---\n",
-		clock());
-	while ((p = deque()) != NULL) {
-		printf("t:%f uid: ", p->time_);
-		printf(UID_PRINTF_FORMAT, p->uid_);
-		printf(" handler: %p\n", p->handler_);
-	}
-}
-
-static class ListSchedulerClass : public TclClass {
-public:
-	ListSchedulerClass() : TclClass("Scheduler/List") {}
-	TclObject* create(int /* argc */, const char*const* /* argv */) {
-		return (new ListScheduler);
-	}
-} class_list_sched;
-
-void 
-ListScheduler::insert(Event* e)
-{
-	double t = e->time_;
-	Event** p;
-	for (p = &queue_; *p != 0; p = &(*p)->next_)
-		if (t < (*p)->time_)
-			break;
-	e->next_ = *p;
-	*p = e;
-}
-
-/*
- * Cancel an event.  It is an error to call this routine
- * when the event is not actually in the queue.  The caller
- * must free the event if necessary; this routine only removes
- * it from the scheduler queue.
- */
-void 
-ListScheduler::cancel(Event* e)
-{
-	Event** p;
-	if (e->uid_ <= 0)	// event not in queue
-		return;
-	for (p = &queue_; *p != e; p = &(*p)->next_)
-		if (*p == 0)
-			abort();
-
-	*p = (*p)->next_;
-	e->uid_ = - e->uid_;
-}
-
-Event* 
-ListScheduler::lookup(scheduler_uid_t uid)
-{
-	Event* e;
-	for (e = queue_; e != 0; e = e->next_)
-		if (e->uid_ == uid)
-			break;
-	return (e);
-}
-
-
-Event*
-ListScheduler::deque()
-{ 
-	Event* e = queue_;
-	if (e)
-		queue_ = e->next_;
-	return (e);
-}
-
-#include "heap.h"
-
-Heap::Heap(int size)
-		: h_s_key(0), h_size(0), h_maxsize(size), h_iter(0)
-{
-	h_elems = new Heap_elem[h_maxsize];
-	memset(h_elems, 0, h_maxsize*sizeof(Heap_elem));
-	//for (unsigned int i = 0; i < h_maxsize; i++)
-	//	h_elems[i].he_elem = 0;
-}
-
-Heap::~Heap()
-{
-	delete [] h_elems;
-}
-
-/*
- * int	heap_member(Heap *h, void *elem):		O(n) algorithm.
- *
- *	Returns index(elem \in h->he_elems[]) + 1,
- *			if elem \in h->he_elems[],
- *		0,	otherwise.
- *	External callers should just test for zero, or non-zero.
- *	heap_delete() uses this routine to find an element in the heap.
- */
-int
-Heap::heap_member(void* elem)
-{
-	unsigned int i;
-	Heap::Heap_elem* he;
-	for (i = 0, he = h_elems; i < h_size; i++, he++)
-		if (he->he_elem == elem)
-			return ++i;
-	return 0;
-}
-
-/*
- * int	heap_delete(Heap *h, void *elem):		O(n) algorithm
- *
- *	Returns 1 for success, 0 otherwise.
- *
- * find elem in h->h_elems[] using heap_member()
- *
- * To actually remove the element from the tree, first swap it to the
- * root (similar to the procedure applied when inserting a new
- * element, but no key comparisons--just get it to the root).
- *
- * Then call heap_extract_min() to remove it & fix the tree.
- * 	This process is not the most efficient, but we do not
- *	particularily care about how fast heap_delete() is.
- *	Besides, heap_member() is already O(n), 
- *	and is the dominating cost.
- *
- * Actually remove the element by calling heap_extract_min().
- * 	The key that is now at the root is not necessarily the
- *	minimum, but heap_extract_min() does not care--it just
- *	removes the root.
- */
-int
-Heap::heap_delete(void* elem)
-{
-	int	i;
-	if ((i = heap_member(elem)) == 0)
-		return 0;
-	for (--i; i; i = parent(i)) {
-		swap(i, parent(i));
-	}
-	(void) heap_extract_min();
-	return 1;
-}
-
-/*
- * void	heap_insert(Heap *h, heap_key_t *key, void *elem)
- *
- * Insert <key, elem> into heap h.
- * Adjust heap_size if we hit the limit.
- * 
- *	i := heap_size(h)
- *	heap_size := heap_size + 1
- *	while (i > 0 and key < h[Parent(i)])
- *	do	h[i] := h[Parent(i)]
- *		i := Parent(i)
- *	h[i] := key
- */
-void
-Heap::heap_insert(heap_key_t key, void* elem) 
-{
-	unsigned int	i, par;
-	if (h_maxsize == h_size) {	/* Adjust heap_size */
-		unsigned int osize = h_maxsize;
-		Heap::Heap_elem *he_old = h_elems;
-		h_maxsize *= 2;
-		h_elems = new Heap::Heap_elem[h_maxsize];
-		memcpy(h_elems, he_old, osize*sizeof(Heap::Heap_elem));
-		delete []he_old;
-	}
-
-	i = h_size++;
-	par = parent(i);
-	while ((i > 0) && 
-	       (KEY_LESS_THAN(key, h_s_key,
-			      h_elems[par].he_key, h_elems[par].he_s_key))) {
-		h_elems[i] = h_elems[par];
-		i = par;
-		par = parent(i);
-	}
-	h_elems[i].he_key  = key;
-	h_elems[i].he_s_key= h_s_key++;
-	h_elems[i].he_elem = elem;
-	return;
-};
-		
-/*
- * void *heap_extract_min(Heap *h)
- *
- *	Returns the smallest element in the heap, if it exists.
- *	NULL otherwise.
- *
- *	if heap_size[h] == 0
- *		return NULL
- *	min := h[0]
- *	heap_size[h] := heap_size[h] - 1   # C array indices start at 0
- *	h[0] := h[heap_size[h]]
- *	Heapify:
- *		i := 0
- *		while (i < heap_size[h])
- *		do	l = HEAP_LEFT(i)
- *			r = HEAP_RIGHT(i)
- *			if (r < heap_size[h])
- *				# right child exists =>
- *				#       left child exists
- *				then	if (h[l] < h[r])
- *						then	try := l
- *						else	try := r
- *				else
- *			if (l < heap_size[h])
- *						then	try := l
- *						else	try := i
- *			if (h[try] < h[i])
- *				then	HEAP_SWAP(h[i], h[try])
- *					i := try
- *				else	break
- *		done
- */
-void*
-Heap::heap_extract_min()
-{
-	void*	min;				  /* return value */
-	unsigned int	i;
-	unsigned int	l, r, x;
-
-	if (h_size == 0)
-		return 0;
-	min = h_elems[0].he_elem;
-	h_elems[0] = h_elems[--h_size];
-// Heapify:
-	i = 0;
-	while (i < h_size) {
-		l = left(i);
-		r = right(i);
-		if (r < h_size) {
-			if (KEY_LESS_THAN(h_elems[l].he_key, h_elems[l].he_s_key,
-					  h_elems[r].he_key, h_elems[r].he_s_key))
-				x= l;
-			else
-				x= r;
-		} else
-			x = (l < h_size ? l : i);
-		if ((x != i) && 
-		    (KEY_LESS_THAN(h_elems[x].he_key, h_elems[x].he_s_key,
-				   h_elems[i].he_key, h_elems[i].he_s_key))) {
-			swap(i, x);
-			i = x;
-		} else {
-			break;
-		}
-	}
-	return min;
-}
-
-
-static class HeapSchedulerClass : public TclClass {
-public:
-	HeapSchedulerClass() : TclClass("Scheduler/Heap") {}
-	TclObject* create(int /* argc */, const char*const* /* argv */) {
-		return (new HeapScheduler);
-	}
-} class_heap_sched;
-
-Event* 
-HeapScheduler::lookup(scheduler_uid_t uid)
-{
-	Event* e;
-	
-	for (e = (Event*) hp_->heap_iter_init(); e;
-	     e = (Event*) hp_->heap_iter())
-		if (e->uid_ == uid)
-			break;
-	return e;
-}
-
-Event*
-HeapScheduler::deque()
-{
-	return ((Event*) hp_->heap_extract_min());
-}
-
-/*
- * Calendar queue scheduler contributed by
- * David Wetherall <djw@juniper.lcs.mit.edu>
- * March 18, 1997.
- *
- * A calendar queue basically hashes events into buckets based on
- * arrival time.
- *
- * See R.Brown. "Calendar queues: A fast O(1) priority queue implementation 
- *  for the simulation event set problem." 
- *  Comm. of ACM, 31(10):1220-1227, Oct 1988
- */
-
-#define CALENDAR_HASH(t) ((int)fmod((t)/width_, nbuckets_))
-
-static class CalendarSchedulerClass : public TclClass {
-public:
-	CalendarSchedulerClass() : TclClass("Scheduler/Calendar") {}
-	TclObject* create(int /* argc */, const char*const* /* argv */) {
-		return (new CalendarScheduler);
-	}
-} class_calendar_sched;
-
-CalendarScheduler::CalendarScheduler() : cal_clock_(clock_) {
-	reinit(4, 1.0, cal_clock_);
-}
-
-CalendarScheduler::~CalendarScheduler() {
-	// XXX free events?
-	delete [] buckets_;
-	qsize_ = 0;
-	stat_qsize_ = 0;
-}
-
-void 
-CalendarScheduler::insert(Event* e)
-{
-	int i;
-	if (cal_clock_ > e->time_) {
-		// may happen in RT scheduler
-		cal_clock_ = e->time_;
-		i = lastbucket_ = CALENDAR_HASH(cal_clock_);
-	} else
-		i = CALENDAR_HASH(e->time_);
-
-	Event *head = buckets_[i].list_;
-	Event *before=0;
-
-	if (!head) {
-		buckets_[i].list_ = e;
-		e->next_ = e->prev_ = e;
-		++stat_qsize_; 
-		++buckets_[i].count_;
-	} else {
-		bool newhead;
-		if (e->time_ >= head->prev_->time_) {
-			// insert at the tail
-			before = head;
-			newhead = false;
-		} else {
-			// insert event in time sorted order, FIFO for sim-time events
-			for (before = head; e->time_ >= before->time_; before = before->next_)
-				;
-			newhead = (before == head);
-		}
-
-		e->next_ = before;
-		e->prev_ = before->prev_;
-		before->prev_ = e;
-		e->prev_->next_ = e;
-		if (newhead) {
-			buckets_[i].list_ = e;
-			//assert(e->time_ <= e->next_->time_);
-		}
-		//assert(e->prev_ != e);
-		if (e->prev_->time_ != e->time_) {
-			// unique timing
-			++stat_qsize_; 
-			++buckets_[i].count_;
-		}
-	}
-	++qsize_;
-	//assert(e == buckets_[i].list_ ||  e->prev_->time_ <= e->time_);
-	//assert(e == buckets_[i].list_->prev_ || e->next_->time_ >= e->time_);
-
-  	if (stat_qsize_ > top_threshold_) {
-  		resize(nbuckets_ << 1, cal_clock_);
-		return;
-	}
-}
-
-void 
-CalendarScheduler::insert2(Event* e)
-{
-	// Same as insert, but for inserts e *before* any same-time-events, if
-	//   there should be any.  Since it is used only by CalendarScheduler::newwidth(),
-	//   some important checks present in insert() need not be performed.
-
-	int i = CALENDAR_HASH(e->time_);
-	Event *head = buckets_[i].list_;
-	Event *before=0;
-	if (!head) {
-		buckets_[i].list_ = e;
-		e->next_ = e->prev_ = e;
-		++stat_qsize_; 
-		++buckets_[i].count_;
-	} else {
-		bool newhead;
-		if (e->time_ > head->prev_->time_) { //strict LIFO, so > and not >=
-			// insert at the tail
-			before = head;
-			newhead = false;
-		} else {
-			// insert event in time sorted order, LIFO for sim-time events
-			for (before = head; e->time_ > before->time_; before = before->next_)
-				;
-			newhead = (before == head);
-		}
-
-		e->next_ = before;
-		e->prev_ = before->prev_;
-		before->prev_ = e;
-		e->prev_->next_ = e;
-		if (newhead) {
-			buckets_[i].list_ = e;
-			//assert(e->time_ <= e->next_->time_);
-		}
-
-		if (e != e->next_ && e->next_->time_ != e->time_) {
-			// unique timing
-			++stat_qsize_; 
-			++buckets_[i].count_;
-		}
-	}
-	//assert(e == buckets_[i].list_ ||  e->prev_->time_ <= e->time_);
-	//assert(e == buckets_[i].list_->prev_ || e->next_->time_ >= e->time_);
-
-	++qsize_;
-	// no need to check resizing
-}
-
-const Event*
-CalendarScheduler::head()
-{
-	if (qsize_ == 0)
-		return NULL;
-
-	int l = -1, i = lastbucket_;
-	int lastbucket_dec = (lastbucket_) ? lastbucket_ - 1 : nbuckets_ - 1;
-	double diff;
-	Event *e, *min_e = NULL;
-#define CAL_DEQUEUE(x) 						\
-do { 								\
-	if ((e = buckets_[i].list_) != NULL) {			\
-		diff = e->time_ - cal_clock_;			\
-		if (diff < diff##x##_)	{			\
-			l = i;					\
-			goto found_l;				\
-		}						\
-		if (min_e == NULL || min_e->time_ > e->time_) {	\
-			min_e = e;				\
-			l = i;					\
-		}						\
-	}							\
-	if (++i == nbuckets_) i = 0;				\
-} while (0)
-		 
-	// CAL_DEQUEUE applied successively will find the event to
-	// dequeue (within one year) and keep track of the
-	// minimum-priority event seen so far; the argument controls
-	// the criteria used to decide whether the event should be
-	// considered `within one year'.  Importantly, the number of
-	// buckets should not be less than 4.
-	CAL_DEQUEUE(0); 
-	CAL_DEQUEUE(1); 
-	for (; i != lastbucket_dec; ) {
-		CAL_DEQUEUE(2);
-	}
-	// one last bucket is left unchecked - take the minimum
-	// [could have done CAL_DEQUEUE(3) with diff3_ = bwidth*(nbuck*3/2-1)]
-	e = buckets_[i].list_;
-	if (min_e != NULL && 
-	    (e == NULL || min_e->time_ < e->time_))
-		e = min_e;
-	else {
-		//assert(e);
-		l = i;
-	}
- found_l:
-	//assert(buckets_[l].count_ >= 0);
-	//assert(buckets_[l].list_ == e);
-
-	/* l is the index of the bucket to dequeue, e is the event */
-	/* 
-	 * still want to advance lastbucket_ and cal_clock_ to save
-	 * time when deque() follows. 
-	 */
-	assert (l != -1);
-	lastbucket_ = l;
- 	cal_clock_  = e->time_;
-	
-	return e;
-}
-
-Event* 
-CalendarScheduler::deque()
-{
-	Event *e = const_cast<Event *>(head());
-
-	if (!e)
-		return 0;
-
-	int l = lastbucket_;
-
-	// update stats and unlink
-	if (e->next_ == e || e->next_->time_ != e->time_) {
-		--stat_qsize_;
-		//assert(stat_qsize_ >= 0);
-		--buckets_[l].count_;
-		//assert(buckets_[l].count_ >= 0);
-
-	}
-	--qsize_;
-
-	if (e->next_ == e)
-		buckets_[l].list_ = 0;
-	else {
-		e->next_->prev_ = e->prev_;
-		e->prev_->next_ = e->next_;
-		buckets_[l].list_ = e->next_;
-	}
-
-	e->next_ = e->prev_ = NULL;
-
-
-	//if (buckets_[l].count_ == 0)
-	//	assert(buckets_[l].list_ == 0);
-
- 	if (stat_qsize_ < bot_threshold_) {
-		resize(nbuckets_ >> 1, cal_clock_);
-	}
-
-	return e;
-}
-
-void 
-CalendarScheduler::reinit(int nbuck, double bwidth, double start)
-{
-	buckets_ = new Bucket[nbuck];
-
-	memset(buckets_, 0, sizeof(Bucket)*nbuck); //faster than ctor
-
-	width_ = bwidth;
-	nbuckets_ = nbuck;
-	qsize_ = 0;
-	stat_qsize_ = 0;
-
-	lastbucket_ =  CALENDAR_HASH(start);
-
-	diff0_ = bwidth*nbuck/2;
-	diff1_ = diff0_ + bwidth;
-	diff2_ = bwidth*nbuck;
-	//diff3_ = bwidth*(nbuck*3/2-1);
-
-	bot_threshold_ = (nbuck >> 1) - 2;
-	top_threshold_ = (nbuck << 1);
-}
-
-void 
-CalendarScheduler::resize(int newsize, double start)
-{
-	double bwidth = newwidth(newsize);
-
-	if (newsize < 4)
-		newsize = 4;
-
-	Bucket *oldb = buckets_;
-	int oldn = nbuckets_;
-
-	reinit(newsize, bwidth, start);
-
-	// copy events to new buckets
-	int i;
-
-	for (i = 0; i < oldn; ++i) {
-		// we can do inserts faster, if we use insert2, but to
-		// preserve FIFO, we have to start from the end of
-		// each bucket and use insert2
-		if  (oldb[i].list_) {
-			Event *tail = oldb[i].list_->prev_;
-			Event *e = tail; 
-			do {
-				Event* ep = e->prev_;
-				e->next_ = e->prev_ = 0;
-				insert2(e);
-				e = ep;
-			} while (e != tail);
-		}
-	}
-	delete [] oldb;
-}
-
-// take samples from the most populated bucket.
-double
-CalendarScheduler::newwidth(int newsize)
-{
-	int i;
-	int max_bucket = 0; // index of the fullest bucket
-	for (i = 1; i < nbuckets_; ++i) {
-		if (buckets_[i].count_ > buckets_[max_bucket].count_)
-			max_bucket = i;
-	}
-	int nsamples = buckets_[max_bucket].count_;
-
-	if (nsamples <= 4) return width_;
-	
-	double nw = buckets_[max_bucket].list_->prev_->time_ 
-		- buckets_[max_bucket].list_->time_;
-	assert(nw > 0);
-	
-	nw /= ((newsize < nsamples) ? newsize : nsamples); // min (newsize, nsamples)
-	nw *= 4.0;
-	
-	return nw;
-}
-
-/*
- * Cancel an event.  It is an error to call this routine
- * when the event is not actually in the queue.  The caller
- * must free the event if necessary; this routine only removes
- * it from the scheduler queue.
- *
- */
-void 
-CalendarScheduler::cancel(Event* e)
-{
-	if (e->uid_ <= 0)	// event not in queue
-		return;
-
-	int i = CALENDAR_HASH(e->time_);
-
-	assert(e->prev_->next_ == e);
-	assert(e->next_->prev_ == e);
-
-	if (e->next_ == e || 
-	    (e->next_->time_ != e->time_ &&
-	    (e->prev_->time_ != e->time_))) { 
-		--stat_qsize_;
-		assert(stat_qsize_ >= 0);
-		--buckets_[i].count_;
-		assert(buckets_[i].count_ >= 0);
-	}
-
-	if (e->next_ == e) {
-		assert(buckets_[i].list_ == e);
-		buckets_[i].list_ = 0;
-	} else {
-		e->next_->prev_ = e->prev_;
-		e->prev_->next_ = e->next_;
-		if (buckets_[i].list_ == e)
-			buckets_[i].list_ = e->next_;
-	}
-
-	if (buckets_[i].count_ == 0)
-		assert(buckets_[i].list_ == 0);
-
-	e->uid_ = -e->uid_;
-	e->next_ = e->prev_ = NULL;
-
-	--qsize_;
-
-	return;
-}
-
-Event * 
-CalendarScheduler::lookup(scheduler_uid_t uid)
-{
-	for (int i = 0; i < nbuckets_; i++) {
-		Event* head =  buckets_[i].list_;
-		Event* p = head;
-		if (p) {
-			do {
-				if (p->uid_== uid) 
-					return p;
-				p = p->next_;
-			} while (p != head);
-		}
-	}
-	return NULL;
-}
-
-#ifndef WIN32
-#include <sys/time.h>
-#endif
-
-class RealTimeScheduler : public CalendarScheduler {
-public:
-	RealTimeScheduler();
-	virtual void run();
-	double start() const { return start_; }
-	virtual void reset();
-protected:
-	void sync() { clock_ = tod(); }
-	double tod();
-	double slop_;	// allowed drift between real-time and virt time
-	double start_;	// starting time
-};
-
-static class RealTimeSchedulerClass : public TclClass {
-public:
-	RealTimeSchedulerClass() : TclClass("Scheduler/RealTime") {}
-	TclObject* create(int /* argc */, const char*const* /* argv */) {
-		return (new RealTimeScheduler);
-	}
-} class_realtime_sched;
-
-RealTimeScheduler::RealTimeScheduler() : start_(0.0)
-{
-	bind("maxslop_", &slop_);
-}
-
-double
-RealTimeScheduler::tod()
-{
-	timeval tv;
-	gettimeofday(&tv, 0);
-	double s = tv.tv_sec;
-	s += (1e-6 * tv.tv_usec);
-	return (s - start_);
-}
-
-void
-RealTimeScheduler::reset()
-{
-	clock_ = SCHED_START;
-	start_ = tod();
-}
-
-void 
-RealTimeScheduler::run()
-{ 
-	static const double RTSCHEDULER_MINWAIT = 1.0e-3; // don't wait for less
-	const Event *p;
-
-	/*XXX*/
-	instance_ = this;
-
-	while (!halted_) {
-		clock_ = tod();
-		p = head();
-		if (p && (clock_ - p->time_) > slop_) {
-			fprintf(stderr,
-				"RealTimeScheduler: warning: slop "
-				"%f exceeded limit %f [clock_:%f, p->time_:%f]\n",
-				clock_ - p->time_, slop_, clock_, p->time_);
-		}
-		// handle "old events"
-		while (p && p->time_ <= clock_) {
-
-			dispatch(deque(), clock_);
-			if (halted_)
-				return;
-			p = head();
-			clock_ = tod();
-		}
-		
-		if (!p) {
-			// blocking wait for TCL events
-			Tcl_WaitForEvent(0); // no sim events, wait forever
-			clock_ = tod();
-		} else {
-			double diff = p->time_ - clock_;
-			// blocking wait only if there is enough time
-			if (diff > RTSCHEDULER_MINWAIT) {
-				Tcl_Time to;
-				to.sec = long(diff);
-				to.usec = long(1e6*(diff - to.sec));
-				Tcl_WaitForEvent(&to);    // block
-				clock_ = tod();
-			}
-		}
-		Tcl_DoOneEvent(TCL_DONT_WAIT);
-	}
-	// we reach here only if halted
-}
diff -rupN ns-2.29/common/scheduler.h.orig ns-2.29-click-scheduler/common/scheduler.h.orig
--- ns-2.29/common/scheduler.h.orig	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/common/scheduler.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,211 +0,0 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1994 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/common/scheduler.h,v 1.27 2005/07/27 01:13:42 tomh Exp $ (LBL)
- */
-
-#ifndef ns_scheduler_h
-#define ns_scheduler_h
-
-#include "config.h"
-
-// Make use of 64 bit integers if available.
-#ifdef HAVE_INT64
-typedef int64_t scheduler_uid_t;
-#define UID_PRINTF_FORMAT STRTOI64_FMTSTR
-#define STRTOUID(S) STRTOI64((S), NULL, 0)
-#else
-typedef int scheduler_uid_t;
-#define UID_PRINTF_FORMAT "%d"
-#define STRTOUID(S) atoi((S))
-#endif
-
-
-class Handler;
-
-class Event {
-public:
-	Event* next_;		/* event list */
-	Event* prev_;
-	Handler* handler_;	/* handler to call when event ready */
-	double time_;		/* time at which event is ready */
-	scheduler_uid_t uid_;	/* unique ID */
-	Event() : time_(0), uid_(0) {}
-};
-
-/*
- * The base class for all event handlers.  When an event's scheduled
- * time arrives, it is passed to handle which must consume it.
- * i.e., if it needs to be freed it, it must be freed by the handler.
- */
-class Handler {
- public:
-	virtual ~Handler () {}
-	virtual void handle(Event* event) = 0;
-};
-
-#define	SCHED_START	0.0	/* start time (secs) */
-
-class Scheduler : public TclObject {
-public:
-	static Scheduler& instance() {
-		return (*instance_);		// general access to scheduler
-	}
-	void schedule(Handler*, Event*, double delay);	// sched later event
-	virtual void run();			// execute the simulator
-	virtual void cancel(Event*) = 0;	// cancel event
-	virtual void insert(Event*) = 0;	// schedule event
-	virtual Event* lookup(scheduler_uid_t uid) = 0;	// look for event
-	virtual Event* deque() = 0;		// next event (removes from q)
-	virtual const Event* head() = 0;	// next event (not removed from q)
-	double clock() const {			// simulator virtual time
-		return (clock_);
-	}
-	virtual void sync() {};
-	virtual double start() {		// start time
-		return SCHED_START;
-	}
-	virtual void reset();
-protected:
-	void dumpq();	// for debug: remove + print remaining events
-	void dispatch(Event*);	// execute an event
-	void dispatch(Event*, double);	// exec event, set clock_
-	Scheduler();
-	virtual ~Scheduler();
-	int command(int argc, const char*const* argv);
-	double clock_;
-	int halted_;
-	static Scheduler* instance_;
-	static scheduler_uid_t uid_;
-};
-
-class ListScheduler : public Scheduler {
-public:
-	ListScheduler() : queue_(0) {}
-	void cancel(Event*);
-	void insert(Event*);
-	Event* deque();
-	const Event* head() { return queue_; }
-	Event* lookup(scheduler_uid_t uid);
-
-protected:
-	Event* queue_;
-};
-
-#include "heap.h"
-
-class HeapScheduler : public Scheduler {
-public:
-	HeapScheduler() { hp_ = new Heap; } 
-	void cancel(Event* e) {
-		if (e->uid_ <= 0)
-			return;
-		e->uid_ = - e->uid_;
-		hp_->heap_delete((void*) e);
-	}
-	void insert(Event* e) {
-		hp_->heap_insert(e->time_, (void*) e);
-	}
-	Event* lookup(scheduler_uid_t uid);
-	Event* deque();
-	const Event* head() { return (const Event *)hp_->heap_min(); }
-protected:
-	Heap* hp_;
-};
-
-class CalendarScheduler : public Scheduler {
-public:
-	CalendarScheduler();
-	~CalendarScheduler();
-	void cancel(Event*);
-	void insert(Event*);
-	Event* lookup(scheduler_uid_t uid);
-	Event* deque();
-	const Event* head();
-
-protected:
-	double width_;
-	double diff0_, diff1_, diff2_; /* wrap-around checks */
-
-	int stat_qsize_;		/* # of distinct priorities in queue*/
-	int nbuckets_;
-	int lastbucket_;
-	int top_threshold_;
-	int bot_threshold_;
-
-	struct Bucket {
-		Event *list_;
-		int    count_;
-	} *buckets_;
-		
-	int qsize_;
-
-	virtual void reinit(int nbuck, double bwidth, double start);
-	virtual void resize(int newsize, double start);
-	virtual double newwidth(int newsize);
-
-private:
-	virtual void insert2(Event*);
-	double cal_clock_;  // same as clock in sims, may be different in RT-scheduling.
-
-};
-
-class SplayScheduler : public Scheduler 
-{
-public:
-	SplayScheduler() : root_(0), qsize_(0) {}
-	void insert(Event *);
-	Event *deque();
-	const Event *head();
-	void cancel(Event *);
-	Event *lookup(scheduler_uid_t);
-
-	//void validate() { assert(validate(root_) == qsize_); };
-    
-protected:
-	/* XXX even if debug is enabled, we want these inlined, so
-	   XXX they are defined as macros in splay-scheduler.cc
-	   Event *&LEFT(Event *e)  { return e->prev_; }
-	   Event *&RIGHT(Event *e) { return e->next_; }
-	*/
-	Event *uid_lookup(Event *);
-
-	Event			*root_;
-	scheduler_uid_t 	lookup_uid_;
-	int 			qsize_;
-private:
-	int validate(Event *);
-};
-
-
-#endif
diff -rupN ns-2.29/diffusion/diffusion.cc ns-2.29-click-scheduler/diffusion/diffusion.cc
--- ns-2.29/diffusion/diffusion.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/diffusion.cc	2007-03-08 15:12:37.000000000 +0100
@@ -459,7 +459,7 @@ void DiffusionAgent::MACsend(Packet *pkt
 }
 
 
-void XmitFailedCallback(Packet *pkt, void *data)
+void XmitFailedCallback(Packet *pkt, void *data, int32_t retries)
 {
   DiffusionAgent *agent = (DiffusionAgent *)data;  // cast of trust
   agent->xmitFailed(pkt);
diff -rupN ns-2.29/diffusion/diffusion.h ns-2.29-click-scheduler/diffusion/diffusion.h
--- ns-2.29/diffusion/diffusion.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/diffusion.h	2008-08-28 16:32:23.000000000 +0200
@@ -137,8 +137,7 @@ class SendBufTimer : public TimerHandler
   DiffusionAgent *a_;
 };
 
-
-void XmitFailedCallback(Packet *pkt, void *data);
+void XmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 class ArpBufferTimer;
 class SendBufTimer;
 
@@ -207,7 +206,7 @@ class DiffusionAgent : public Agent {
 
   void trace(char *fmt,...);
 
-  friend void XmitFailedCallback(Packet *pkt, void *data);
+  friend void XmitFailedCallback(Packet *pkt, void *data, int32_t retries);
   friend class ArpBufferTimer;
   friend class SendBufTimer;
 };
diff -rupN ns-2.29/diffusion/omni_mcast.cc ns-2.29-click-scheduler/diffusion/omni_mcast.cc
--- ns-2.29/diffusion/omni_mcast.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/omni_mcast.cc	2007-03-08 15:12:37.000000000 +0100
@@ -419,7 +419,7 @@ void OmniMcastAgent::MACsend(Packet *pkt
 }
 
 
-void OmniMcastXmitFailedCallback(Packet *pkt, void *data)
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries)
 {
   OmniMcastAgent *agent = (OmniMcastAgent *)data;  // cast of trust
   agent->xmitFailed(pkt);
diff -rupN ns-2.29/diffusion/omni_mcast.h ns-2.29-click-scheduler/diffusion/omni_mcast.h
--- ns-2.29/diffusion/omni_mcast.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/omni_mcast.h	2008-08-28 16:33:12.000000000 +0200
@@ -157,7 +157,7 @@ class OmniMcast_Entry {
 
 
 
-void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 
 class OmniMcastArpBufferTimer;
 class OmniMcastSendBufTimer;
@@ -222,7 +222,7 @@ class OmniMcastAgent : public Agent {
 
   void trace(char *fmt,...);
 
-  friend void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+  friend void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 
   friend class OmniMcastArpBufferTimer;
   friend class OmniMcastSendBufTimer;
diff -rupN ns-2.29/dsdv/dsdv.cc ns-2.29-click-scheduler/dsdv/dsdv.cc
--- ns-2.29/dsdv/dsdv.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/dsdv/dsdv.cc	2007-03-08 15:12:37.000000000 +0100
@@ -413,7 +413,7 @@ DSDV_Agent::lost_link (Packet *p)
 }
 
 static void 
-mac_callback (Packet * p, void *arg)
+mac_callback (Packet * p, void *arg, int32_t retries)
 {
   ((DSDV_Agent *) arg)->lost_link (p);
 }
diff -rupN ns-2.29/dsr/dsragent.cc ns-2.29-click-scheduler/dsr/dsragent.cc
--- ns-2.29/dsr/dsragent.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/dsr/dsragent.cc	2007-03-08 15:12:37.000000000 +0100
@@ -2786,14 +2786,14 @@ DSRAgent::xmitFailed(Packet *pkt, const 
 }
 
 void
-XmitFailureCallback(Packet *pkt, void *data)
+XmitFailureCallback(Packet *pkt, void *data, int32_t retries)
 {
   DSRAgent *agent = (DSRAgent *)data; // cast of trust
   agent->xmitFailed(pkt);
 }
 
 void
-XmitFlowFailureCallback(Packet *pkt, void *data)
+XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries)
 {
   DSRAgent *agent = (DSRAgent *)data;
   agent->xmitFlowFailed(pkt);
diff -rupN ns-2.29/dsr/dsragent.h ns-2.29-click-scheduler/dsr/dsragent.h
--- ns-2.29/dsr/dsragent.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/dsr/dsragent.h	2008-08-28 16:36:13.000000000 +0200
@@ -110,8 +110,8 @@ protected:
 
 LIST_HEAD(DSRAgent_List, DSRAgent);
 
-void XmitFailureCallback(Packet *pkt, void *data);
-void XmitFlowFailureCallback(Packet *pkt, void *data);
+void XmitFailureCallback(Packet *pkt, void *data, int32_t retries);
+void XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries);
 int FilterFailure(Packet *p, void *data);
 class SendBufferTimer;
 
@@ -270,8 +270,8 @@ private:
   void testinit();
   void trace(char* fmt, ...);
 
-  friend void XmitFailureCallback(Packet *pkt, void *data);
-  friend void XmitFlowFailureCallback(Packet *pkt, void *data);
+  friend void XmitFailureCallback(Packet *pkt, void *data, int32_t retries);
+  friend void XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries);
   friend int FilterFailure(Packet *p, void *data);
   friend class SendBufferTimer;
 
diff -rupN ns-2.29/imep/imep.cc ns-2.29-click-scheduler/imep/imep.cc
--- ns-2.29/imep/imep.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/imep/imep.cc	2007-03-08 15:12:37.000000000 +0100
@@ -76,7 +76,7 @@ public:
 
 // MAC layer callback
 static void
-imep_failed_callback(Packet *p, void *arg)
+imep_failed_callback(Packet *p, void *arg, int32_t retries)
 {
 	if(imep_use_mac_callback)
 		((imepAgent*) arg)->imepPacketUndeliverable(p);
diff -rupN ns-2.29/mac/arp.cc ns-2.29-click-scheduler/mac/arp.cc
--- ns-2.29/mac/arp.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/arp.cc	2007-03-08 15:12:37.000000000 +0100
@@ -161,7 +161,7 @@ ARPTable::arpresolve(nsaddr_t dst, Packe
 
                         if (ch->xmit_failure_) {
                                 ch->xmit_reason_ = 0;
-                                ch->xmit_failure_(t, ch->xmit_failure_data_);
+                                ch->xmit_failure_(t, ch->xmit_failure_data_, -1);
                         }
                         else {
                                 drop(t, DROP_IFQ_ARP_FULL);
@@ -172,7 +172,7 @@ ARPTable::arpresolve(nsaddr_t dst, Packe
 
 		if (ch->xmit_failure_) {
                         ch->xmit_reason_ = 0;
-                        ch->xmit_failure_(p, ch->xmit_failure_data_);
+                        ch->xmit_failure_(p, ch->xmit_failure_data_, -1);
                 }
                 else {
                         drop(p, DROP_IFQ_ARP_FULL);
diff -rupN ns-2.29/mac/channel.cc ns-2.29-click-scheduler/mac/channel.cc
--- ns-2.29/mac/channel.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/mac/channel.cc	2007-03-08 15:12:37.000000000 +0100
@@ -387,7 +387,10 @@ WirelessChannel::sendUp(Packet* p, Phy *
 			 
 			 rifp = (rnode->ifhead()).lh_first;
 			 for(; rifp; rifp = rifp->nextnode()){
-				 s.schedule(rifp, newp, propdelay);
+        if (rifp->channel() == this){
+         s.schedule(rifp, newp, propdelay); 
+         break;
+        }
 			 }
 		 }
 		 delete [] affectedNodes;
diff -rupN ns-2.29/mac/mac-802_11.cc ns-2.29-click-scheduler/mac/mac-802_11.cc
--- ns-2.29/mac/mac-802_11.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-802_11.cc	2007-03-08 15:12:37.000000000 +0100
@@ -81,7 +81,21 @@ inline void
 Mac802_11::checkBackoffTimer()
 {
 	if(is_idle() && mhBackoff_.paused())
-		mhBackoff_.resume(phymib_.getDIFS());
+		// BUGFIX UKA: EIFS
+		// When the channel becomes free again the station will have
+        // to back off with DIFS or EIFS period depending on the
+        // last received packet
+
+        // old implementation
+		// mhBackoff_.resume(phymib_.getDIFS());
+         
+        // new implementation
+		if (last_packet_correct_ == true)
+			mhBackoff_.resume(phymib_.getDIFS());
+        else
+            mhBackoff_.resume(phymib_.getEIFS());
+		// BUGFIX UKA END: EIFS
+
 	if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.paused())
 		mhBackoff_.pause();
 }
@@ -106,7 +120,22 @@ Mac802_11::transmit(Packet *p, double ti
 		//assert(dh->dh_fc.fc_subtype == MAC_Subtype_ACK);
 		assert(pktRx_);
 		struct hdr_cmn *ch = HDR_CMN(pktRx_);
-		ch->error() = 1;        /* force packet discard */
+
+	    // BUGFIX UKA: TxRxError
+        // If a station transmits it cannot sense and thus not receive
+        // packets at the same time physically. In the original simulator 
+        // however such a packet is "received", marked errornous, discarded
+        // and an EIFS period follows.
+        // This however should not happen, because the packet is not sensed.
+        // Therefore the packet that is received is marked special and handled
+        // correctly after complete "reception" (handle it as "never sensed")
+		
+        // old implementation
+        //ch->error() = 1;        /* force packet discard */
+        
+        // new implementation
+    ch->error() = TX_RX_ERROR;
+    // BUGFIX UKA END: TxRxError
 	}
 
 	/*
@@ -167,6 +196,13 @@ PHY_MIB::PHY_MIB(Mac802_11 *parent)
 	parent->bind("PreambleLength_", &PreambleLength);
 	parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);
 	parent->bind_bw("PLCPDataRate_", &PLCPDataRate);
+
+    // BUGFIX UKA: capture
+    // bind variable 
+    // Set newchipset_ to false for classical chipset behavior
+    // Set to true for improved capture support.
+    parent->bind_bool("newchipset_", &newchipset);
+    // BUGFIX UKA END: capture
 }
 
 MAC_MIB::MAC_MIB(Mac802_11 *parent)
@@ -205,6 +241,16 @@ Mac802_11::Mac802_11() : 
 	cache_ = 0;
 	cache_node_count_ = 0;
 	
+    // BUGFIX UKA: capture
+    // saves the point of time of the start of the last packet reception
+    time_start_pktRx_= 0.0;
+    // BUGFIX UKA END: capture
+
+    // BUGFIX UKA: EIFS
+    // On initialization the last received packet is assumed as correct.
+    last_packet_correct_ = true;
+    // BUGFIX UKA END: EIFS
+
 	// chk if basic/data rates are set
 	// otherwise use bandwidth_ as default;
 	
@@ -406,6 +452,50 @@ Mac802_11::is_idle()
 	return 1;
 }
 
+// BUGFIX UKA: EIFS
+// Two new functions for setting and resetting EIFS state
+
+// Set_eifs: This method is called after an errornous packet
+// reception, It sets last_packet_correct to false and
+// starts the defer timer if backoff is not already running 
+// (in that case, the backoff timer cares about EIFS on
+// resume (see checkbackofftimer()).
+
+inline void
+Mac802_11::set_eifs() {
+last_packet_correct_ = false;
+  /*
+   *  Stop deferring - will be reset in tx_resume().
+   */
+  if(mhDefer_.busy()) mhDefer_.stop();
+
+if (mhBackoff_.busy() == false)  {
+    mhDefer_.start(phymib_.getEIFS());
+}
+
+}
+
+// reset_eifs: If the station starts receiving a packet, reset_eifs is
+// called. It checks if the station is in the EIFS period and if this is
+// done by defer timer. If this is the case the defer timer is stopped. If
+// there are packets to send then the station will initialize a backoff
+// period (if not already running), that is directly paused until the 
+// medium is idle again.
+
+inline void
+Mac802_11::reset_eifs()
+{
+if (last_packet_correct_ == false && mhDefer_.busy() == true) {
+    mhDefer_.stop();
+    if (mhBackoff_.busy() == false && (pktRTS_ || pktTx_)) {
+        mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+
+    }
+}
+}
+
+// BUGFIX UKA END: EIFS
+
 void
 Mac802_11::discard(Packet *p, const char* why)
 {
@@ -471,12 +561,51 @@ Mac802_11::discard(Packet *p, const char
 void
 Mac802_11::capture(Packet *p)
 {
-	/*
-	 * Update the NAV so that this does not screw
-	 * up carrier sense.
-	 */	
-	set_nav(usec(phymib_.getEIFS() + txtime(p)));
-	Packet::free(p);
+// BUGFIX UKA: capture, EIFS
+// Changes concerning capture effect:
+// - Packets that are discarded because of the capture effect are 
+//   mentioned in  the trace
+// - A new version of the chipset implementation that handles an 
+//   "extended capture effect" is implemented
+// Changes concerning EIFS handling:
+// - NAV is not used for EIFS handling anymore; replace by mechnism
+//   using last_packet_correct_ variable and defer/backoff timers
+
+// old implementation
+
+/*
+ * Update the NAV so that this does not screw
+ * up carrier sense.
+ */
+// set_nav(usec(phymib_.getEIFS() + txtime(p)));
+// Packet::free(p);
+
+// new implementation
+
+last_packet_correct_ = false;
+
+if (phymib_.get_newchipset() == false) {
+    // handle the classical capture effect (new chipset feature is not used)
+    discard(p, DROP_MAC_CAPTURE);
+} else {
+// handle capture effect if (new chipset feature used)
+
+    if (pktRx_->txinfo_.RxPr > p->txinfo_.RxPr){
+        // RxPr first packet > RxPr second packet 
+        // (power difference a priori big enough, otherwise capture is not called)
+        // => continue receive packet 1, discard packet 2
+        discard(p,DROP_MAC_CAPTURE);
+    } else {
+        // RxPr first packet < RxPr second packet 
+        // (power difference a priori big enough, otherwise capture is not called)
+        // => stop receive packet 1 and discard, receive packet 2 from now on
+        mhRecv_.stop();                     // receive timer for packet 1 stopped
+        mhRecv_.start(txtime(p));           // start receive timer for packet 2
+        discard(pktRx_, DROP_MAC_CAPTURE);  // discard packet 1
+        pktRx_ = p;                         // make packet 2 the one that is received now
+    }
+}
+// BUGFIX UKA END: capture, EIFS
 }
 
 void
@@ -495,6 +624,13 @@ Mac802_11::collision(Packet *p)
 		 *  "last" the longest.  Make this packet,
 		 *  pktRx_ and reset the Recv Timer if necessary.
 		 */
+
+    // BUGFIX UKA: EIFS
+    // A collision implies reception of an errornous packet
+    // set the last_packet_correct_ variable to false
+     last_packet_correct_ = false;
+    // BUGFIX UKA END: EIFS
+
 		if(txtime(p) > mhRecv_.expire()) {
 			mhRecv_.stop();
 			discard(pktRx_, DROP_MAC_COLLISION);
@@ -513,6 +649,9 @@ Mac802_11::collision(Packet *p)
 void
 Mac802_11::tx_resume()
 {
+  if (mhDefer_.busy())
+    dump("mac-802.11");
+    
 	double rTime;
 	assert(mhSend_.busy() == 0);
 	assert(mhDefer_.busy() == 0);
@@ -524,8 +663,20 @@ Mac802_11::tx_resume()
 		mhDefer_.start(phymib_.getSIFS());
 	} else if(pktRTS_) {
 		if (mhBackoff_.busy() == 0) {
-			rTime = (Random::random() % cw_) * phymib_.getSlotTime();
-			mhDefer_.start( phymib_.getDIFS() + rTime);
+        // BUGFIX UKA: transmission 
+        //
+        // Do backoff period using the (interruptable) backoff timer, not
+        // the (non-interruptable) defer timer
+        
+        // old implementation
+        
+        //rTime = (Random::random() % cw_) * phymib_.getSlotTime();
+        //mhDefer_.start( phymib_.getDIFS() + rTime);
+        
+        // new implementation
+        
+        mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        //BUGFIX UKA END: transmission 
 		}
 	} else if(pktTx_) {
 		if (mhBackoff_.busy() == 0) {
@@ -534,9 +685,21 @@ Mac802_11::tx_resume()
 			
 			if ((u_int32_t) ch->size() < macmib_.getRTSThreshold()
 			    || (u_int32_t) ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
-				rTime = (Random::random() % cw_)
-					* phymib_.getSlotTime();
-				mhDefer_.start(phymib_.getDIFS() + rTime);
+            // BUGFIX UKA: transmission 
+            //
+            // Do backoff period using the (interruptable) backoff timer,
+            // not the (non-interruptable) defer timer
+
+            // old implementation
+        
+            // rTime = (Random::random() % cw_)
+            //	* phymib_.getSlotTime();
+            // mhDefer_.start(phymib_.getDIFS() + rTime);
+            
+            // new implementation
+            
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: transmission 
                         } else {
 				mhDefer_.start(phymib_.getSIFS());
                         }
@@ -579,7 +742,21 @@ Mac802_11::backoffHandler()
 void
 Mac802_11::deferHandler()
 {
-	assert(pktCTRL_ || pktRTS_ || pktTx_);
+// BUGFIX UKA: EIFS
+
+// Defer timer is also used for EIFS handling now. This method is called at
+// the end of a complete EIFS. The assertion needs to be extended and the 
+// last_packet_correct_ variable has to be reset.
+
+// old implementation
+
+// assert(pktCTRL_ || pktRTS_ || pktTx_);
+
+// new implementation
+
+assert(pktCTRL_ || pktRTS_ || pktTx_ || last_packet_correct_ == false);
+last_packet_correct_ = true;
+// BUGFIX UKA END: EIFS
 
 	if(check_pktCTRL() == 0)
 		return;
@@ -593,8 +770,19 @@ Mac802_11::deferHandler()
 void
 Mac802_11::navHandler()
 {
-	if(is_idle() && mhBackoff_.paused())
-		mhBackoff_.resume(phymib_.getDIFS());
+// BUGFIX UKA: NAV 
+// If NAV finishes, paused backoff timers have to be resumed.
+// Use the appropriate method instead of an individual solution here.
+
+// old implementation
+
+// if(is_idle() && mhBackoff_.paused())
+// mhBackoff_.resume(phymib_.getDIFS());
+
+// new implementation
+
+checkBackoffTimer();
+// BUGFIX UKA END: NAV
 }
 
 void
@@ -738,8 +926,26 @@ Mac802_11::check_pktRTS()
  	switch(mh->dh_fc.fc_subtype) {
 	case MAC_Subtype_RTS:
 		if(! is_idle()) {
-			inc_cw();
-			mhBackoff_.start(cw_, is_idle());
+			// BUGFIX UKA: transmission 
+            // The contention window should only be increased before retransmit
+            // (see Standard spec. section 9.2.4)
+            
+            // old implementation
+            
+            // inc_cw();
+            // BUGFIX UKA END: transmission
+            
+            // BUGFIX UKA: EIFS
+            // changed method definition for backoff start causes changed call
+            
+            // old implementation
+             
+			// mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+             
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
 			return 0;
 		}
 		setTxState(MAC_RTS);
@@ -776,8 +982,27 @@ Mac802_11::check_pktTx()
 	case MAC_Subtype_Data:
 		if(! is_idle()) {
 			sendRTS(ETHER_ADDR(mh->dh_ra));
-			inc_cw();
-			mhBackoff_.start(cw_, is_idle());
+			// BUGFIX UKA: transmission 
+            // The contention window should only be increased before retransmit
+            // (see Standard spec. section 9.2.4)
+            
+            // old implementation
+            
+            // inc_cw();
+            // BUGFIX UKA END: transmission 
+            
+            // BUGFIX UKA: EIFS
+            // changed method definition for backoff start causes changed call
+            
+            // old implementation
+             
+			// mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+             
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
+			
 			return 0;
 		}
 		setTxState(MAC_SEND);
@@ -999,6 +1224,51 @@ Mac802_11::sendDATA(Packet *p)
 /* ======================================================================
    Retransmission Routines
    ====================================================================== */
+
+// BUGFIX UKA: EIFS
+//
+// The new implementation of EIFS causes a more complicated retransmission 
+// handling. Depending on the expiration time of EIFS backoff timers have to 
+// be initialized with different waiting times. Since this functionality
+// is needed at severeal places in the RetransmitRTS and RetransmitDATA 
+// methods, it is expoerted to an own method, StartRetransmitBackoff.
+
+void
+Mac802_11::StartRetransmitBackoff()
+{
+    // Set tx state to idle first so that the correct waiting time is used.
+    // This is VERY dirty, but if the medium is not idle here, we would never start
+    // e.g. with expire time of defer handler, but it would always be paused directly
+    // and on resume, DIFS or EIFS is chosen.
+    // 
+    // This call does not change anything, because after leaving this method, we
+    // leave RestransmitRTS/DATA, and then, this call comes in send_timer in every
+    // case, where tx state would be set to idle.
+    setTxState(MAC_IDLE);
+
+    if (last_packet_correct_ == false && mhDefer_.busy()) {
+    	// defer is running because of EIFS => stop defering, start backoff
+        if (mhDefer_.expire() < phymib_.getDIFS()) {
+            // time until defer expires is shorter than DIFS => start BO with DIFS
+            mhDefer_.stop();
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        } else {
+            // time until defer expires is greater than DIFS => wait rest of defer
+	        // (complete EIFS) and do backoff slots then
+            mhBackoff_.start(cw_, is_idle(), mhDefer_.expire());
+            mhDefer_.stop();
+        }
+     } else {
+        // no defer running; just start backoff
+        if (mhBackoff_.busy() == false) {
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        }
+    }
+}
+
+// BUGFIX UKA END:EIFS
+
+
 void
 Mac802_11::RetransmitRTS()
 {
@@ -1024,7 +1294,8 @@ Mac802_11::RetransmitRTS()
 			ch->size() -= phymib_.getHdrLen11();
                         ch->xmit_reason_ = XMIT_REASON_RTS;
                         ch->xmit_failure_(pktTx_->copy(),
-                                          ch->xmit_failure_data_);
+                                          ch->xmit_failure_data_,
+                                          ssrc_);
                 }
 		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
 		pktTx_ = 0;
@@ -1036,8 +1307,27 @@ Mac802_11::RetransmitRTS()
 		rf->rf_fc.fc_retry = 1;
 
 		inc_cw();
-		mhBackoff_.start(cw_, is_idle());
-	}
+		// BUGFIX UKA: EIFS
+		// call StartRetransmitBackoff instead of directly starting backoff
+		// This is now done at the end of this method.
+
+        // old implementation
+         
+		// mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA END: EIFS
+	}
+    
+	// BUGFIX UKA: transmission, EIFS
+	// transmission: backoff is started here, because it has to be done in every
+	// case and not only in case of not reaching the limit.
+	// EIFS: backoff is not started directly but uses StartRetransmitBackoff 
+    // method.
+
+    // new implementation
+
+    StartRetransmitBackoff();
+	// BUGFIX UKA END: transmission, EIFS
+
 }
 
 void
@@ -1046,7 +1336,15 @@ Mac802_11::RetransmitDATA()
 	struct hdr_cmn *ch;
 	struct hdr_mac802_11 *mh;
 	u_int32_t *rcount, thresh;
-	assert(mhBackoff_.busy() == 0);
+	
+    // BUGFIX UKA: EIFS
+    // This assertion is not always valid, the BO timer might already be 
+    // running after an EIFS period
+    
+    // old implementation
+    
+    // assert(mhBackoff_.busy() == 0);
+    // BUGFIX UKA END: EIFS
 
 	assert(pktTx_);
 	assert(pktRTS_ == 0);
@@ -1062,11 +1360,28 @@ Mac802_11::RetransmitDATA()
 		Packet::free(pktTx_); 
 		pktTx_ = 0;
 
-		/*
+        // BUGFIX UKA: transmission 
+        // After sending a packet with a group address, both the short and 
+        // long retry counter should be reset (see Standard 9.2.4)
+        ssrc_ = 0;
+        slrc_ = 0;
+        // BUGFIX UKA END: transmission
+
+        /*
 		 * Backoff at end of TX.
 		 */
 		rst_cw();
-		mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA: EIFS
+		// Call StartRetransmitBackoff instead of directly starting backoff
+
+        // old implementation
+
+		// mhBackoff_.start(cw_, is_idle());
+    
+        // new implementation
+
+		StartRetransmitBackoff();
+		// BUGFIX UKA END: EIFS
 
 		return;
 	}
@@ -1094,7 +1409,8 @@ Mac802_11::RetransmitDATA()
                         ch->size() -= phymib_.getHdrLen11();
 			ch->xmit_reason_ = XMIT_REASON_ACK;
                         ch->xmit_failure_(pktTx_->copy(),
-                                          ch->xmit_failure_data_);
+                                          ch->xmit_failure_data_,
+                                          -1);
                 }
 
 		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
@@ -1107,11 +1423,28 @@ Mac802_11::RetransmitDATA()
 		dh = HDR_MAC802_11(pktTx_);
 		dh->dh_fc.fc_retry = 1;
 
-
 		sendRTS(ETHER_ADDR(mh->dh_ra));
 		inc_cw();
-		mhBackoff_.start(cw_, is_idle());
-	}
+		// BUGFIX UKA: EIFS
+		// Call StartRetransmitBackoff at the ned of the method instead of 
+        // directly starting backoff
+
+        // old implementation
+
+		// mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA END: EIFS
+	}
+    
+	// BUGFIX UKA: transmission, EIFS
+	// transmission: backoff is started here, because it has to be done in every
+	// case and not only in case of not reaching the limit.
+	// EIFS: backoff is not started directly but uses StartRetransmitBackoff 
+    // method.
+
+    // new implementation
+
+    StartRetransmitBackoff();
+	// BUGFIX UKA END: transmission, EIFS
 }
 
 /* ======================================================================
@@ -1149,16 +1482,57 @@ Mac802_11::send(Packet *p, Handler *h)
 				 * If we are already deferring, there is no
 				 * need to reset the Defer timer.
 				 */
-				rTime = (Random::random() % cw_)
-					* (phymib_.getSlotTime());
-				mhDefer_.start(phymib_.getDIFS() + rTime);
+				// BUGFIX UKA: transmission 
+				// The station must defer only for DIFS if the medium is free
+                // and the is no backoff or defer runnning
+                
+                // old implementation
+                 
+				// rTime = (Random::random() % cw_)
+				// 	* (phymib_.getSlotTime());
+				// mhDefer_.start(phymib_.getDIFS() + rTime);
+                
+                // new implementation
+                
+				mhDefer_.start(phymib_.getDIFS() );
+				// BUGFIX UKA END: transmission
+
+			}
+			// BUGFIX UKA: EIFS
+			// support of EIFS causes new situations at packet sending as well
+            // If the last packet was not correct and defer is running and the
+            // medium is free, defer runs in an EIFS period. If now the time
+            // until expiration is smaller than DIFS, it is necessary to wait
+            // at least for an additional period of DIFS before sending.
+            
+            // new implementation
+			
+            else {
+				if (last_packet_correct_ == false && mhDefer_.expire() < phymib_.getDIFS()) {
+					// Defer runs because of EIFS and expiration
+					// time is shorter than DIFS
+					// => defer for DIFS again
+					mhDefer_.stop();
+					mhDefer_.start(phymib_.getDIFS());
+				}
 			}
+			// BUGFIX UKA END: EIFS
 		} else {
 			/*
 			 * If the medium is NOT IDLE, then we start
 			 * the backoff timer.
 			 */
-			mhBackoff_.start(cw_, is_idle());
+            // BUGFIX UKA: EIFS
+            // method call for backoff start changed
+            
+            // old implementation
+             
+            // mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+            
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
 		}
 	}
 }
@@ -1194,9 +1568,35 @@ Mac802_11::recv(Packet *p, Handler *h)
 	 *  proceed.  Just set the error flag in the common header
 	 *  to that the packet gets thrown away.
 	 */
-	if(tx_active_ && hdr->error() == 0) {
-		hdr->error() = 1;
-	}
+	// BUGFIX UKA: TxRxError
+    // packets at the same time physically. In the original simulator 
+    // however such a packet is "received", marked errornous, discarded
+    // and an EIFS period follows.
+    // This however should not happen, because the packet is not sensed.
+    // Therefore the packet that is received is marked special and handled
+    // correctly after complete "reception" (handle it as "never sensed")
+    
+    // old implementation
+
+	//if(tx_active_ && hdr->error() == 0) {
+	//	hdr->error() = 1;
+	// }
+    
+    // new implementation
+    
+	if (tx_active_) {
+	 	hdr->error() = TX_RX_ERROR;
+	}
+	// BUGFIX UKA END: TxRxError
+
+	// BUGFIX UKA: EIFS
+    // on receiving a packet, a running EIFS period is stopped
+
+    // new implementation
+    
+	reset_eifs();
+	// BUGFIX UKA END: EIFS
+
 
 	if(rx_state_ == MAC_IDLE) {
 		setRxState(MAC_RECV);
@@ -1206,17 +1606,70 @@ Mac802_11::recv(Packet *p, Handler *h)
 		 * txtime seconds.
 		 */
 		mhRecv_.start(txtime(p));
-	} else {
+        // BUGFIX UKA: capture
+        // The starting time of packet reception has to be stored to make sure
+        // the capture mechanism is simulated correctly. The new capture
+        // effect does not work if the starting time of the second packet 
+        // reception is in the interval between 4 and 10ms after the start of 
+        // the first reception.
+
+        // new implementation
+        
+		time_start_pktRx_ = Scheduler::instance().clock();
+		// BUGFIX UKA END: capture
+	
+    } else {
 		/*
 		 *  If the power of the incoming packet is smaller than the
 		 *  power of the packet currently being received by at least
                  *  the capture threshold, then we ignore the new packet.
 		 */
-		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
-			capture(p);
+        // BUGFIX UKA: capture
+        // Also support the new capture effect (can be activated and
+        // deactivated using the tcl variable newchipset_). In case of 
+        // activation a capture is also possible if the packet arriving
+        // later has a higher power of reception and does not reach the
+        // receiver within an interval of 4 to 10ms after start of reception
+        // of the first packet due to synchronization constraints.
+
+        // old implementation
+        
+        /*
+    		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
+	    		capture(p);
+		    } else {
+			    collision(p);
+		    }
+        */
+
+        // new implementation
+        
+        // store current time and capture threshold 
+        // (given in dB; transform to a factor)
+		double now = Scheduler::instance().clock();
+    	double Threshold = pow(10,p->txinfo_.CPThresh/10);
+        if (phymib_.get_newchipset() == false) {
+            // classic chipset, capture only possible if first packet is stronger
+	    	if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= Threshold) {
+				capture(p);
+			} else {
+				collision(p);
+			}
 		} else {
-			collision(p);
-		}
+		    // improved chipset
+			if (pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= Threshold){
+				capture(p);
+			} else if ((p->txinfo_.RxPr / pktRx_->txinfo_.RxPr >= Threshold )&&
+				   ((time_start_pktRx_ + 4e-6 > now)||(time_start_pktRx_ + 10e-6 < now))) {
+				   // in case that second packet is stronger, check if
+                   // sychronization is possible
+				capture(p);
+				time_start_pktRx_ = now;
+			} else {
+				collision(p);
+			}
+        }
+        // BUGFIX UKA END: capture
 	}
 }
 
@@ -1239,17 +1692,44 @@ Mac802_11::recv_timer()
          *  "arrives", then I would never have seen it and should
          *  do a silent discard without adjusting the NAV.
          */
-        if(tx_active_) {
-                Packet::free(pktRx_);
-                goto done;
-        }
+	// BUGFIX UKA: TxRxError
+    // Discard a packet that reaches the station during a transmission.
+    // The packet could technically not be received, however it is 
+    // possible in simulation. Therefore, such packets are marked
+    // special and just ignored after complete "reception".
+    
+    // old implementation
+    
+    //if(tx_active_) {
+    //        Packet::free(pktRx_);
+    //        goto done;
+    //}
+    
+    // new implementation
+	
+    if(tx_active_ || ch->error() == TX_RX_ERROR) {
+		Packet::free(pktRx_);
+		goto done;
+     	}
+	// BUGFIX UKA END: TxRxError
 
 	/*
 	 * Handle collisions.
 	 */
 	if(rx_state_ == MAC_COLL) {
 		discard(pktRx_, DROP_MAC_COLLISION);		
-		set_nav(usec(phymib_.getEIFS()));
+		// BUGFIX UKA: EIFS
+		// Start an EIFS period instead of the NAV timer by calling set_eifs
+
+        // old implementation
+        
+		// set_nav(usec(phymib_.getEIFS()));
+		
+        // new implementation
+        
+		set_eifs();
+		// BUGFIX UKA END: EIFS
+        
 		goto done;
 	}
 
@@ -1261,10 +1741,30 @@ Mac802_11::recv_timer()
 	 */
 	if( ch->error() ) {
 		Packet::free(pktRx_);
-		set_nav(usec(phymib_.getEIFS()));
+        // BUGFIX UKA: EIFS
+		// Start an EIFS period instead of the NAV timer by calling set_eifs
+
+        // old implementation
+        
+		// set_nav(usec(phymib_.getEIFS()));
+		
+        // new implementation
+        
+		set_eifs();
+		// BUGFIX UKA END: EIFS
+		
 		goto done;
 	}
 
+	// BUGFIX UKA: EIFS
+	// At this point it is sure that an error-free packet is received. 
+    // Remember this fact.
+	
+    // new implementation
+    
+    last_packet_correct_ = true;
+	// BUGFIX UKA END: EIFS
+
 	/*
 	 * IEEE 802.11 specs, section 9.2.5.6
 	 *	- update the NAV (Network Allocation Vector)
@@ -1273,11 +1773,12 @@ Mac802_11::recv_timer()
 		set_nav(mh->dh_duration);
 	}
 
-        /* tap out - */
-        if (tap_ && type == MAC_Type_Data &&
-            MAC_Subtype_Data == subtype ) {
+  /* tap out - */
+  if (tap_ && type == MAC_Type_Data && MAC_Subtype_Data == subtype ) 
+  {
 		if (!tap_filterown_ ||
-		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) {
+		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) 
+    {
 			tap_->tap(pktRx_);
 		}
 	}
@@ -1326,6 +1827,17 @@ Mac802_11::recv_timer()
 				subtype);
 			exit(1);
 		}
+
+        // BUGFIX UKA: Memory 
+        // The memory used by MAC Control packets should be freed if packets 
+        // are received and not used anymore This step was missing in the
+        // original implementation.
+        
+        // new implementation
+        
+        Packet::free(pktRx_);
+        // BUGFIX UKA END: Memory
+        
 		break;
 	case MAC_Type_Data:
 		switch(subtype) {
@@ -1482,8 +1994,35 @@ Mac802_11::recvDATA(Packet *p)
 				return;
 			}
 			sendACK(src);
-			if(mhSend_.busy() == 0)
-				tx_resume();
+            // BUGFIX UKA: transmission 
+            // An ACK packet should be sent in every case directly after a SIFS 
+            // period, even if there is a timeout pending 
+            // (See 9.2.8 in the Standard)
+            
+            // old implementation
+            
+            // if(mhSend_.busy() == 0)
+			//  tx_resume();
+            
+            // new implementation
+            
+            /*
+             *  Stop deferring - will be reset in tx_resume().
+             */
+            if(mhDefer_.busy()) mhDefer_.stop();
+
+            if (mhSend_.busy() == 0) {
+                tx_resume();
+            } 
+            else
+            {
+                // the station is waiting for a timeout. Stop waiting and 
+                // schedule a retransmit (done by sendHandler). tx_resume 
+                // to send the ACK is called from within sendHandler!
+                mhSend_.stop();
+                sendHandler();
+            }
+            // BUGFIX UKA END: transmission 
 		}
 	}
 	
@@ -1534,9 +2073,12 @@ Mac802_11::recvDATA(Packet *p)
 	 * the dh_3a field for the 'interested in the info'
 	 * receiver; we finally push the packet towards the
 	 * LL to be added back to my queue - accomplish this
-	 * by reversing the direction!*/
-
-	if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST)&& ((u_int32_t)ETHER_ADDR(dh->dh_3a) != ((u_int32_t)addr()))) {
+	 * by reversing the direction!
+   * */
+	if ( bss_id() == addr() 
+    && (u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST
+    && (u_int32_t)ETHER_ADDR(dh->dh_3a) != (u_int32_t)addr() ) 
+  {
 		struct hdr_cmn *ch = HDR_CMN(p);
 		u_int32_t dst = ETHER_ADDR(dh->dh_3a);
 		u_int32_t src = ETHER_ADDR(dh->dh_ta);
@@ -1580,6 +2122,23 @@ Mac802_11::recvACK(Packet *p)
 		ssrc_ = 0;
 	else
 		slrc_ = 0;
+
+        // TX feedback
+        u_int32_t *rcount;
+        hdr_cmn *ch = HDR_CMN(pktTx_);
+
+	if((u_int32_t) ch->size() <= macmib_.getRTSThreshold()) {
+          rcount = &ssrc_;
+        } else {
+          rcount = &slrc_;
+        }
+
+//        ch->size() -= phymib_.getHdrLen11();
+        ch->xmit_reason_ = XMIT_REASON_ACK;
+        ch->xmit_failure_(pktTx_->copy(),
+                          ch->xmit_failure_data_,
+                          *rcount);
+
 	rst_cw();
 	Packet::free(pktTx_); 
 	pktTx_ = 0;
@@ -1588,7 +2147,17 @@ Mac802_11::recvACK(Packet *p)
 	 * Backoff before sending again.
 	 */
 	assert(mhBackoff_.busy() == 0);
-	mhBackoff_.start(cw_, is_idle());
+    // BUGFIX UKA: EIFS
+    // changed method definition for backoff start causes changed call
+            
+    // old implementation
+             
+    // Backoff_.start(cw_, is_idle());
+            
+    // new implementation
+             
+    mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+    // BUGFIX UKA END: EIFS
 
 	tx_resume();
 
diff -rupN ns-2.29/mac/mac-802_11.h ns-2.29-click-scheduler/mac/mac-802_11.h
--- ns-2.29/mac/mac-802_11.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-802_11.h	2007-03-08 15:12:37.000000000 +0100
@@ -168,6 +168,17 @@ public:
 	inline u_int32_t getACKlen() {
 		return(getPLCPhdrLen() + sizeof(struct ack_frame));
 	}
+    
+    // BUGFIX UKA: capture
+    // returns true if the new implementation of the chipset is supported, 
+    // otherwise false
+    
+    // new implementation
+    
+    inline bool get_newchipset() {
+        return newchipset;
+    }
+    // BUGFIX UKA END: capture
 
  private:
 
@@ -181,6 +192,14 @@ public:
 	u_int32_t	PreambleLength;
 	u_int32_t	PLCPHeaderLength;
 	double		PLCPDataRate;
+    
+    // BUGFIX UKA: capture
+    // true if new chipset implementation is used, false otherwise
+    
+    // new implementation
+    
+    int newchipset;     
+    // BUGFIX UKA END: capture
 };
 
 
@@ -226,6 +245,17 @@ public:
 /* ======================================================================
    The actual 802.11 MAC class.
    ====================================================================== */
+
+// BUGFIX UKA: TxRxError
+// Define a specific value to mark packets that are not really received
+// because of the RxTxError
+
+// new implementation
+
+#define TX_RX_ERROR 5
+// BUGFIX UKA END: TxRxError
+
+
 class Mac802_11 : public Mac {
 	friend class DeferTimer;
 
@@ -276,7 +306,16 @@ private:
 	void	sendCTS(int dst, double duration);
 	void	sendACK(int dst);
 	void	sendDATA(Packet *p);
-	void	RetransmitRTS();
+
+	// BUGFIX UKA: EIFS
+	// definition of new method
+    
+    // new implementation
+    
+	void	StartRetransmitBackoff();
+	// BUGFIX UKA END: EIFS
+	
+    void	RetransmitRTS();
 	void	RetransmitDATA();
 
 	/*
@@ -320,6 +359,14 @@ private:
 	inline void setRxState(MacState newState);
 	inline void setTxState(MacState newState);
 
+	// BUGFIX UKA: EIFS
+	// declaration of methods to set and reset EIFS
+    
+    // new implementation
+    
+	inline void set_eifs();
+	inline void reset_eifs();
+	// BUGFIX UKA END: EIFS
 
 	inline void inc_cw() {
 		cw_ = (cw_ << 1) + 1;
@@ -377,7 +424,23 @@ private:
 	   ============================================================ */
 	double		nav_;		// Network Allocation Vector
 
-	MacState	rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
+	// BUGFIX UKA: EIFS
+	// variable that remembers if the last received packet was error-free
+    
+    // new implementation
+    
+	int		last_packet_correct_;
+	// BUGFIX UKA END: EIFS
+
+	// BUGFIX UKA: CAPTURE
+    // Variable saving the time of reception start
+    
+    // new implementation
+    
+	double time_start_pktRx_;
+	// BUGFIX UKA END: CAPTURE
+	
+    MacState	rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
 	MacState	tx_state_;	// outgoint state
 	int		tx_active_;	// transmitter is ACTIVE
 
diff -rupN ns-2.29/mac/mac-timers.cc ns-2.29-click-scheduler/mac/mac-timers.cc
--- ns-2.29/mac/mac-timers.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-timers.cc	2007-03-08 15:12:37.000000000 +0100
@@ -221,8 +221,23 @@ BackoffTimer::handle(Event *)
 	mac->backoffHandler();
 }
 
+// BUGFIX UKA: EIFS
+// New additional parameter for this method, specifing the time the backoff 
+// process should wait before counting down the slots.
+// The value is of interest ONLY if medium is NOT busy at the moment 
+// of calling this method!
+
+// old implementation
+
+//void
+//BackoffTimer::start(int cw, int idle)
+
+// new implementation    
+
 void
-BackoffTimer::start(int cw, int idle)
+BackoffTimer::start(int cw, int idle, double time)
+// BUGFIX UKA END: EIFS
+
 {
 	Scheduler &s = Scheduler::instance();
 
@@ -239,14 +254,33 @@ BackoffTimer::start(int cw, int idle)
 #ifdef USE_SLOT_TIME
 	ROUND_TIME();
 #endif
-	difs_wait = 0.0;
 
+	// BUGFIX UKA: EIFS
+	// use the time parameter if necessary
+
+	// old implementation
+	
+    /*
+	difs_wait = 0.0;
 	if(idle == 0)
 		paused_ = 1;
 	else {
 		assert(rtime >= 0.0);
 		s.schedule(this, &intr, rtime);
 	}
+	*/
+
+	// new implementation
+	
+    if(idle == 0) {
+		difs_wait = 0.0;
+		paused_ = 1;
+    } else {
+		difs_wait = time;
+		assert(rtime >= 0.0);
+		s.schedule(this, &intr, rtime + difs_wait);
+	}
+	// BUGFIX UKA END: EIFS
 }
 
 
diff -rupN ns-2.29/mac/mac-timers.h ns-2.29-click-scheduler/mac/mac-timers.h
--- ns-2.29/mac/mac-timers.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-timers.h	2007-03-08 15:12:37.000000000 +0100
@@ -73,11 +73,19 @@ protected:
 class BackoffTimer : public MacTimer {
 public:
 	BackoffTimer(Mac802_11 *m) : MacTimer(m), difs_wait(0.0) {}
-
-
-
-	void	start(int cw, int idle);
-	void	handle(Event *e);
+	// BUGFIX UKA: EIFS
+	// new declaration of start method with new parameter
+	
+	// old implementation
+    
+    // void	start(int cw, int idle);
+    
+    // new implementation
+	
+    void	start(int cw, int idle, double time);
+	// BUGFIX UKA END: EIFS
+	
+    void	handle(Event *e);
 	void	pause(void);
 	void	resume(double difs);
 private:
diff -rupN ns-2.29/Makefile.in ns-2.29-click-scheduler/Makefile.in
--- ns-2.29/Makefile.in	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/Makefile.in	2007-03-08 15:12:37.000000000 +0100
@@ -263,6 +263,7 @@ OBJ_CC = \
 	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
 	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
 	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
+	westwood/tcp-westwood-nr.o \
 	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
 	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
 	linkstate/hdr-ls.o \
diff -rupN ns-2.29/mobile/dumb-agent.h ns-2.29-click-scheduler/mobile/dumb-agent.h
--- ns-2.29/mobile/dumb-agent.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mobile/dumb-agent.h	2007-03-08 15:12:37.000000000 +0100
@@ -53,6 +53,7 @@
 #ifndef NS_DUMB_AGENT_H
 #define NS_DUMB_AGENT_H
 
+#include <stdarg.h>
 #include "agent.h"
 #include "ll.h"
 #include "trace.h"
diff -rupN ns-2.29/mobile/god.h ns-2.29-click-scheduler/mobile/god.h
--- ns-2.29/mobile/god.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/mobile/god.h	2007-03-08 15:12:37.000000000 +0100
@@ -85,20 +85,20 @@ public:
 		return sqrt(X*X + Y*Y + Z*Z);
 	}
 
-	inline void operator=(const vector a) {
+	inline void vector::operator=(const vector a) {
 		X = a.X;
 		Y = a.Y;
 		Z = a.Z;
 	}
-	inline void operator+=(const vector a) {
+	inline void vector::operator+=(const vector a) {
 		X += a.X;
 		Y += a.Y;
 		Z += a.Z;
 	}
-	inline int operator==(const vector a) {
+	inline int vector::operator==(const vector a) {
 		return (X == a.X && Y == a.Y && Z == a.Z);
 	}
-	inline int operator!=(const vector a) {
+	inline int vector::operator!=(const vector a) {
 		return (X != a.X || Y != a.Y || Z != a.Z);
 	}
 	inline vector operator-(const vector a) {
diff -rupN ns-2.29/pgm/pgm-agent.cc ns-2.29-click-scheduler/pgm/pgm-agent.cc
--- ns-2.29/pgm/pgm-agent.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/pgm/pgm-agent.cc	2007-03-08 15:12:37.000000000 +0100
@@ -304,7 +304,7 @@ protected:
 
   void print_stats();
 
-  void trace_event(char *evType, double evTime);
+  void PgmAgent::trace_event(char *evType, double evTime);
 
 #ifdef PGM_DEBUG
   void display_packet(Packet *pkt);
diff -rupN ns-2.29/pgm/pgm-receiver.cc ns-2.29-click-scheduler/pgm/pgm-receiver.cc
--- ns-2.29/pgm/pgm-receiver.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/pgm/pgm-receiver.cc	2007-03-08 15:12:37.000000000 +0100
@@ -183,7 +183,7 @@ protected:
   void print_stats();
   void display_packet(Packet *pkt); // For debugging.
 
-  void trace_event(char *evType, double evTime);
+  void PgmReceiver::trace_event(char *evType, double evTime);
 
   EventTrace * et_;  //Trace Object for Custom Event Trace
 
diff -rupN ns-2.29/pgm/pgm-sender.cc ns-2.29-click-scheduler/pgm/pgm-sender.cc
--- ns-2.29/pgm/pgm-sender.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/pgm/pgm-sender.cc	2007-03-08 15:12:37.000000000 +0100
@@ -186,7 +186,7 @@ protected:
 
   void display_packet(Packet *pkt); // For debugging.
 
-  void trace_event(char *evType, nsaddr_t daddr, double evTime); 
+  void PgmSender::trace_event(char *evType, nsaddr_t daddr, double evTime); 
 
   EventTrace * et_; 	//Trace Object for custom Event Traces
 
diff -rupN ns-2.29/sctp/sctp.h ns-2.29-click-scheduler/sctp/sctp.h
--- ns-2.29/sctp/sctp.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/sctp/sctp.h	2008-08-28 16:51:52.000000000 +0200
@@ -702,7 +702,7 @@ protected:
 
   /* debugging functions
    */
-  void		DumpSendBuffer();
+  void DumpSendBuffer();
 
   /* sctp association state variable
    */
diff -rupN ns-2.29/tcl/ex/nsclick-simple-hybrid.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-hybrid.tcl
--- ns-2.29/tcl/ex/nsclick-simple-hybrid.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-hybrid.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -189,7 +189,7 @@ for {set i 0} {$i < $wirelessnodecount }
     # "eth2" and so on.
     #
     $wireless_node_($i) add-interface $wireless_chan_ $prop_ $netll \
-	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+	    $wirelessmac $netifq 1 $wirelessphy $antenna
 
     #
     # Now configure the interface eth0
@@ -270,7 +270,7 @@ set bridge_node_ [$ns_ node]
 $bridge_node_ add-wired-interface $wired_chan_ $netll $wiredmac \
 	$netifq 1 $wiredphy
 $bridge_node_ add-interface $wireless_chan_ $prop_ $netll \
-	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+	    $wirelessmac $netifq 1 $wirelessphy $antenna
 
 $bridge_node_ random-motion 0
 $bridge_node_ topography $wtopo
@@ -361,12 +361,10 @@ $wired_node_(2) set Z_ 0
 #
 for {set i 0} {$i < $wirelessnodecount} {incr i} {
     $ns_ initial_node_pos $wireless_node_($i) 10
-    [$wireless_node_($i) entry] runclick
 }
 
 for {set i 0} {$i < $wirednodecount} {incr i} {
     $ns_ initial_node_pos $wired_node_($i) 10
-    [$wired_node_($i) entry] runclick
 }
 
 $ns_ initial_node_pos $bridge_node_ 10
diff -rupN ns-2.29/tcl/ex/nsclick-simple-lan.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-lan.tcl
--- ns-2.29/tcl/ex/nsclick-simple-lan.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-lan.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -249,7 +249,6 @@ $node_(3) set Z_ 0
 #
 for {set i 0} {$i < $nodecount} {incr i} {
     $ns_ initial_node_pos $node_($i) 20
-    [$node_($i) entry] runclick
 }
 
 #
diff -rupN ns-2.29/tcl/ex/nsclick-simple-wlan.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-wlan.tcl
--- ns-2.29/tcl/ex/nsclick-simple-wlan.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-wlan.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -166,7 +166,7 @@ for {set i 0} {$i < $nodecount } {incr i
     # "eth2" and so on.
     #
     $node_($i) add-interface $chan_1_ $prop_ $netll $netmac \
-	$netifq 1 $netphy $antenna $wtopo
+	$netifq 1 $netphy $antenna
 
     #
     # Now configure the interface eth0
@@ -273,7 +273,6 @@ $node_(3) set Z_ 0
 #
 for {set i 0} {$i < $nodecount} {incr i} {
     $ns_ initial_node_pos $node_($i) 20
-    [$node_($i) entry] runclick
 }
 
 #
diff -rupN ns-2.29/tcl/lib/ns-autoconf.tcl ns-2.29-click-scheduler/tcl/lib/ns-autoconf.tcl
--- ns-2.29/tcl/lib/ns-autoconf.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/tcl/lib/ns-autoconf.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,50 @@
+# -*-	Mode:tcl -*-
+#
+# Copyright (c) 1997 University of Southern California.
+# All rights reserved.                                            
+#                                                                
+# Redistribution and use in source and binary forms are permitted
+# provided that the above copyright notice and this paragraph are
+# duplicated in all such forms and that any documentation, advertising
+# materials, and other materials related to such distribution and use
+# acknowledge that the software was developed by the University of
+# Southern California, Information Sciences Institute.  The name of the
+# University may not be used to endorse or promote products derived from
+# this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
+# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+#
+
+# This file should contain variables changed only by autoconf.
+
+proc checkout_executable {exe_var best alternate text} {
+	global $exe_var
+	set $exe_var $best
+	if {"$best" == "" || ![file executable $best]} {
+		puts stderr $text
+		set $exe_var $alternate
+	}
+}
+
+#
+# Keep track of where the good perl is.
+#
+checkout_executable PERL "/usr/bin/perl" perl "\
+	When configured, ns found the right version of perl in\
+	/usr/bin/perl
+	but it doesn't seem to be there anymore, so\
+	ns will fall back on running the first perl in your path.\
+	The wrong version of perl may break the test suites.\
+	Reconfigure and rebuild ns if this is a problem.\
+"
+checkout_executable TCLSH "/usr/bin/tclsh8.4" tclsh "\
+	When configured, ns found the right version of tclsh in\
+	/usr/bin/tclsh8.4
+	but it doesn't seem to be there anymore, so\
+	ns will fall back on running the first tclsh in your path.\
+	The wrong version of tclsh may break the test suites.\
+	Reconfigure and rebuild ns if this is a problem.\
+"
diff -rupN ns-2.29/tcl/lib/ns-default.tcl ns-2.29-click-scheduler/tcl/lib/ns-default.tcl
--- ns-2.29/tcl/lib/ns-default.tcl	2005-10-20 06:45:23.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/lib/ns-default.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -674,7 +674,10 @@ Snoop set debug_ false
  Mac/802_11 set ShortRetryLimit_       7               ;# retransmittions
  Mac/802_11 set LongRetryLimit_        4               ;# retransmissions
 
-
+# BUGFIX UKA: capture 
+# By default, new implementation of the card chipset is deactivated.
+ Mac/802_11 set newchipset_ false
+# BUGFIX UKA END: capture 
 
 # 
 # Support for Abstract LAN
@@ -804,6 +807,41 @@ Agent/SCTP set rcdCount_ 0             ;
 Agent/SCTP/MultipleFastRtx set mfrCount_ 0                                    
 Agent/SCTP/MfrTimestamp set mfrCount_ 0    
 
+# Added for TCP WestwoodNR
+
+Agent/TCP/WestwoodNR set openadd_ 1
+Agent/TCP/WestwoodNR set current_bwe_ 0
+Agent/TCP/WestwoodNR set last_bwe_sample_ 0
+Agent/TCP/WestwoodNR set unaccounted_ 0
+Agent/TCP/WestwoodNR set fr_a_ 1
+Agent/TCP/WestwoodNR set min_rtt_estimate 10000
+Agent/TCP/WestwoodNR set myseqno_ 1
+
+Agent/TCP/WestwoodNR set lastackno_ 0
+Agent/TCP/WestwoodNR set lastackrx_ 0
+Agent/TCP/WestwoodNR set fr_alpha_ 0.9
+Agent/TCP/WestwoodNR set filter_type_ 4
+Agent/TCP/WestwoodNR set tau_ 1.0
+Agent/TCP/WestwoodNR set west_type_ 3.0
+Agent/TCP/WestwoodNR set qest_ 0.0
+Agent/TCP/WestwoodNR set fr_amin_ 0.0
+Agent/TCP/WestwoodNR set fr_amax_ 0.0
+Agent/TCP/WestwoodNR set total_time_ 0.0
+Agent/TCP/WestwoodNR set total_size_ 0.0
+Agent/TCP/WestwoodNR set interp_type_ 0.0
+Agent/TCP/WestwoodNR set fr_prev_ 1.0
+Agent/TCP/WestwoodNR set last_seq_ 0
+Agent/TCP/WestwoodNR set last_echoed_ts_ 0.0
+Agent/TCP/WestwoodNR set last_ts_ 0.0
+Agent/TCP/WestwoodNR set last_cwnd_ 1.0
+
+Agent/TCP/WestwoodNR set current_ts_ 0.0
+Agent/TCP/WestwoodNR set current_echoed_ts_ 0.0
+Agent/TCP/WestwoodNR set newreno_changes_ 0
+Agent/TCP/WestwoodNR set newreno_changes1_ 0
+Agent/TCP/WestwoodNR set partial_window_deflation_ 0
+Agent/TCP/WestwoodNR set exit_recovery_fix_ 0
+
 
 Agent/TCP set seqno_ 0
 Agent/TCP set t_seqno_ 0
diff -rupN ns-2.29/tcp/tcp.cc ns-2.29-click-scheduler/tcp/tcp.cc
--- ns-2.29/tcp/tcp.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp.cc	2007-03-08 15:12:37.000000000 +0100
@@ -673,6 +673,7 @@ void TcpAgent::output(int seqno, int rea
 	tcph->ts_echo() = ts_peer_;
 	tcph->reason() = reason;
 	tcph->last_rtt() = int(int(t_rtt_)*tcp_tick_*1000);
+  tcph->window_ = size_ * (int)wnd_; // TODO 
 
 	if (ecn_) {
 		hf->ect() = 1;	// ECN-capable transport
@@ -1725,6 +1726,9 @@ int TcpAgent::lossQuickStart()
  */
 void TcpAgent::recv(Packet *pkt, Handler*)
 {
+  if (rawcvt_) 
+    fromraw(pkt);
+
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 	int valid_ack = 0;
 	if (qs_approved_ == 1 && tcph->seqno() > last_ack_) 
diff -rupN ns-2.29/tcp/tcp-full.cc ns-2.29-click-scheduler/tcp/tcp-full.cc
--- ns-2.29/tcp/tcp-full.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp-full.cc	2007-03-08 15:12:37.000000000 +0100
@@ -831,7 +831,8 @@ FullTcpAgent::sendpacket(int seqno, int 
 	tcph->sa_length() = 0;    // may be increased by build_options()
         tcph->hlen() = tcpip_base_hdr_size_;
 	tcph->hlen() += build_options(tcph);
-
+  tcph->window_ = maxseg_ * (int)wnd_; // TODO 
+  
 	/*
 	 * Explicit Congestion Notification (ECN) related:
 	 * Bits in header:
@@ -1471,6 +1472,9 @@ FullTcpAgent::set_initial_window()
 void
 FullTcpAgent::recv(Packet *pkt, Handler*)
 {
+  if (rawcvt_) 
+    fromraw(pkt);
+
 	hdr_tcp *tcph = hdr_tcp::access(pkt);	// TCP header
 	hdr_cmn *th = hdr_cmn::access(pkt);	// common header (size, etc)
 	hdr_flags *fh = hdr_flags::access(pkt);	// flags (CWR, CE, bits)
@@ -1719,8 +1723,8 @@ FullTcpAgent::recv(Packet *pkt, Handler*
 			((ackno <= iss_) || (ackno > maxseq_))) {
 			// not an ACK for our SYN, discard
 			fprintf(stderr,
-			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: ",
-			        now(), name());
+			    "%f: FullTcpAgent::recv(%s): bad ACK for our SYN: %d, maxseq=%d",
+			        now(), name(), ackno, (int)maxseq_);
 			prpkt(pkt);
 			goto dropwithreset;
 		}
diff -rupN ns-2.29/tcp/tcp.h ns-2.29-click-scheduler/tcp/tcp.h
--- ns-2.29/tcp/tcp.h	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp.h	2007-03-08 15:12:37.000000000 +0100
@@ -55,6 +55,7 @@ struct hdr_tcp {
 	int tcp_flags_;         /* TCP flags for FullTcp */
 	int last_rtt_;		/* more recent RTT measurement in ms, */
 				/*   for statistics only */
+  int window_;
 
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
diff -rupN ns-2.29/tcp/tcp-sack-rh.cc ns-2.29-click-scheduler/tcp/tcp-sack-rh.cc
--- ns-2.29/tcp/tcp-sack-rh.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp-sack-rh.cc	2007-03-08 15:12:37.000000000 +0100
@@ -65,7 +65,7 @@ class SackRHTcpAgent : public TcpAgent {
 	virtual void estadjust();
 	virtual void rhclear();
 	virtual void computefack();
-	virtual void newack(Packet* pkt);
+	virtual void SackRHTcpAgent::newack(Packet* pkt);
  protected:
 	int fack_;	          /* the FACK state variable  */
 	int retran_data_;         /* the number of retransmitted packets in the pipe  */
diff -rupN ns-2.29/tcp/tcp-sink.cc ns-2.29-click-scheduler/tcp/tcp-sink.cc
--- ns-2.29/tcp/tcp-sink.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp-sink.cc	2007-03-08 15:12:37.000000000 +0100
@@ -290,6 +290,7 @@ void TcpSink::ack(Packet* opkt)
 	// get the cumulative sequence number to put in the ACK; this
 	// is just the left edge of the receive window - 1
 	ntcp->ts() = now;
+  ntcp->window_ = otcp->window_; // TODO 
 	// timestamp the packet
 
 	if (ts_echo_bugfix_)  /* TCP/IP Illustrated, Vol. 2, pg. 870 */
@@ -350,6 +351,9 @@ void TcpSink::add_to_ack(Packet*)
 
 void TcpSink::recv(Packet* pkt, Handler*)
 {
+  if (rawcvt_) 
+    fromraw(pkt);
+
 	int numToDeliver;
 	int numBytes = hdr_cmn::access(pkt)->size();
 	// number of bytes in the packet just received
diff -rupN ns-2.29/tcp/tcp-vegas.cc ns-2.29-click-scheduler/tcp/tcp-vegas.cc
--- ns-2.29/tcp/tcp-vegas.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/tcp/tcp-vegas.cc	2007-03-08 15:12:37.000000000 +0100
@@ -162,6 +162,9 @@ VegasTcpAgent::recv_newack_helper(Packet
 void
 VegasTcpAgent::recv(Packet *pkt, Handler *)
 {
+  if (rawcvt_) 
+    fromraw(pkt);
+
 	double currentTime = vegastime();
 	hdr_tcp *tcph = hdr_tcp::access(pkt);
 	hdr_flags *flagh = hdr_flags::access(pkt);
@@ -460,6 +463,7 @@ VegasTcpAgent::output(int seqno, int rea
 	tcph->seqno() = seqno;
 	tcph->ts() = now;
 	tcph->reason() = reason;
+  tcph->window_ = size_ * (int)wnd_; // TODO 
 
 	/* if this is the 1st pkt, setup senttime[] and transmits[]
 	 * I alloc mem here, instrad of in the constructor, to cover
diff -rupN ns-2.29/trace/cmu-trace.cc ns-2.29-click-scheduler/trace/cmu-trace.cc
--- ns-2.29/trace/cmu-trace.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/trace/cmu-trace.cc	2007-03-08 15:12:37.000000000 +0100
@@ -64,7 +64,7 @@
 #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
 
 
-//#define LOG_POSITION
+#define LOG_POSITION
 
 //extern char* pt_names[];
 
@@ -540,7 +540,7 @@ CMUTrace::format_tcp(Packet *p, int offs
 }
 
 /* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
- * (with help from Florina Almenrez <florina@@it,uc3m,es>)
+ * (with help from Florina Almenrez <florina@@it,uc3m,es>)
  */
 void
 CMUTrace::format_sctp(Packet* p,int offset)
@@ -937,7 +937,7 @@ CMUTrace::nam_format(Packet *p, int offs
 	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
 	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
 	  "UNKN"
-	  ) : packet_info.name(ch->ptype())));
+	  ) : (packet_info.name(ch->ptype()) == NULL) ? "UNKN" : packet_info.name(ch->ptype()) ));
 	//</zheng: add for 802.15.4>
         int dst = Address::instance().get_nodeaddr(ih->daddr());
 
diff -rupN ns-2.29/trace/cmu-trace.h ns-2.29-click-scheduler/trace/cmu-trace.h
--- ns-2.29/trace/cmu-trace.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/trace/cmu-trace.h	2007-03-08 15:12:37.000000000 +0100
@@ -66,6 +66,12 @@
 
 #define DROP_END_OF_SIMULATION		"END"
 #define	DROP_MAC_COLLISION		"COL"
+
+// BUGFIX UKA: capture
+// packet drop in case of a packet capture
+#define DROP_MAC_CAPTURE        "CAP"
+// BUGFIX UKA END: capture
+
 #define DROP_MAC_DUPLICATE		"DUP"
 #define DROP_MAC_PACKET_ERROR		"ERR"
 #define DROP_MAC_RETRY_COUNT_EXCEEDED	"RET"
diff -rupN ns-2.29/westwood/mhop.tcl ns-2.29-click-scheduler/westwood/mhop.tcl
--- ns-2.29/westwood/mhop.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/westwood/mhop.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,412 @@
+#type of the source traversing oll the hops: reno, westwood or vegas
+set conn_type [lindex $argv 0]
+#capacity of the links between consecutive hops
+set bw [lindex $argv 1]
+#number of hops
+set hop [lindex $argv 2]
+#loss rate of the last link
+set perdite [lindex $argv 3]
+#select the filter used by westwood (set $filt=4 to simulate westwood+, $filt=3 to simulate westwood)
+set filter [lindex $argv 4]
+#kind of cross traffic sources: reno, westwood or vegas
+set cross [lindex $argv 5]
+#capacity of the last link
+set bw_last [lindex $argv 6]
+
+
+set stringa "$conn_type $bw $hop $perdite $filter $cross $bw_last"
+
+
+#Create a simulator object
+set ns [new Simulator]
+
+
+#Open the output files
+set q0 [open q.tr w]
+#congestion window values of the forward connections
+set cwndf [open cwnd.tr w]
+#sequence numbers of the forward connections
+set snf [open sn.tr w]
+#bandwidth estimates of the forward connections
+set bwef [open bwe.tr w]
+#rtts measuered by the forward connections
+set rttf [open rtt.tr w]
+#slow start thtreshold of the forward connections
+set sstf [open sst.tr w]
+
+#buffers have been dimensionated assuming a maximum RTT=250ms
+
+set buffer [expr ((($bw*250000)/(1500*8)))]
+set bw [expr ($bw*1000000)]
+
+set bufferlast [expr ((($bw_last*250000)/(1500*8)))]
+set bwlast [expr ($bw_last*1000000)]
+
+
+#if you want to set up a minimum bound on the bottleneck queue length uncomment the following 6 lines
+
+#if ($buffer<20) {
+#	set buffer 20
+#		 }
+# if ($bufferlast<20) {
+#	set bufferlast 20
+#	 }
+
+
+
+set nf [open out.nam w]
+#$ns namtrace-all $nf
+set f [open out.tr w]
+#$ns trace-all $f
+
+
+set Rfirst [$ns node]
+set Rlast [$ns node]
+set Sender [$ns node]
+set Receiver [$ns node]
+
+#all links have a 10ms delay
+
+#set delay [expr (0.025/(3+2*$hop))]
+set delay 0.01
+
+#set delayhop [expr ((0.025-$delay)/2)]
+set delayhop 0.01
+
+#set delay1 [expr ($delay+0.05)]
+set delay1 0.01
+
+$ns duplex-link $Sender $Rfirst 1000Mb $delay1 DropTail
+$ns queue-limit $Sender $Rfirst 1000000
+$ns queue-limit $Rfirst $Sender 1000000
+
+$ns duplex-link $Receiver $Rlast $bwlast $delay1 DropTail
+$ns queue-limit $Receiver $Rlast $bufferlast
+$ns queue-limit $Rlast $Receiver $bufferlast
+
+	switch $conn_type {
+    "reno" {
+         set tcpl [new Agent/TCP/Newreno]
+         }
+    "westwood"  {
+        set tcpl [new Agent/TCP/WestwoodNR]
+
+       }
+       "vegas"  {
+        set tcpl [new Agent/TCP/Vegas]
+       }
+ 		}
+
+        $tcpl set window_ 1000
+        $tcpl set maxcwnd_ 1000
+        $tcpl set windowInit_ 1
+	$tcpl set packetSize_ 1500
+	$tcpl set filter_type_ $filter
+	$tcpl set tau_ 1.0
+	$tcpl set west_type_ 3
+	$tcpl set useHeaders_ 0
+	$tcpl set interp_type_ 0
+	$tcpl set windowInitOption_ 2
+	#$tcpl set timestamps_ 1
+
+
+	$ns attach-agent $Sender $tcpl
+	set ftpl [new Application/FTP]
+
+	set sinkl [new Agent/TCPSink/DelAck]
+	$ns attach-agent $Receiver $sinkl
+
+	$ns connect $tcpl $sinkl
+	$ftpl attach-agent $tcpl
+	$ns at 0.0 "$ftpl start"
+
+#Create nodes
+for {set i 0} {$i < $hop} {incr i} {
+
+	set nsender($i) [$ns node]
+	set nrecv($i) [$ns node]
+
+	set nsenderrew($i) [$ns node]
+	set nrecvrew($i) [$ns node]
+
+        set nfirst($i) [$ns node]
+	set nlast($i) [$ns node]
+
+	$ns duplex-link $nfirst($i) $nlast($i) $bw $delay DropTail
+	$ns queue-limit $nfirst($i) $nlast($i) $buffer
+	$ns queue-limit $nlast($i) $nfirst($i) $buffer
+
+        $ns duplex-link $nsender($i) $nfirst($i) 1000Mb $delayhop DropTail
+	$ns queue-limit $nfirst($i) $nsender($i) $buffer
+	$ns queue-limit $nsender($i) $nfirst($i) 100000
+
+	$ns duplex-link $nrecv($i) $nlast($i) 1000Mb $delayhop DropTail
+	$ns queue-limit $nlast($i) $nrecv($i) $buffer
+	$ns queue-limit $nrecv($i) $nlast($i) 100000
+
+ 	$ns duplex-link $nrecvrew($i) $nfirst($i) 1000Mb $delayhop DropTail
+	$ns queue-limit $nfirst($i) $nrecvrew($i) $buffer
+	$ns queue-limit $nrecvrew($i) $nfirst($i) 100000
+
+	$ns duplex-link $nsenderrew($i) $nlast($i) 1000Mb $delayhop DropTail
+	$ns queue-limit $nlast($i) $nsenderrew($i) $buffer
+	$ns queue-limit $nsenderrew($i) $nlast($i) 100000
+
+
+	if {$i>0} {
+    	$ns duplex-link $nfirst($i) $nlast([expr ($i-1)]) $bw $delay DropTail
+	$ns queue-limit $nfirst($i) $nlast([expr ($i-1)]) $buffer
+	$ns queue-limit $nlast([expr ($i-1)]) $nfirst($i) $buffer
+    	}
+
+
+	}
+
+$ns duplex-link $Rfirst $nfirst(0) $bw $delay DropTail
+$ns queue-limit $Rfirst $nfirst(0) $buffer
+$ns queue-limit $nfirst(0) $Rfirst 1000000
+
+$ns duplex-link $Rlast $nlast([expr ($hop-1)]) $bw $delay DropTail
+$ns queue-limit $Rlast $nlast([expr ($hop-1)]) 1000000
+$ns queue-limit $nlast([expr ($hop-1)]) $Rlast $buffer
+
+set u [new RandomVariable/Uniform]
+$u set min_ 1
+$u set max_ 500
+
+set u1 [new RandomVariable/Uniform]
+$u1 set min_ 500
+$u1 set max_ 1000
+
+
+for {set i 0} {$i < $hop} {incr i} {
+
+
+	switch $cross {
+    "reno" {
+         set tcp($i) [new Agent/TCP/Newreno]
+	 set tcprew($i) [new Agent/TCP/Newreno]
+         }
+    "westwood"  {
+        set tcp($i) [new Agent/TCP/WestwoodNR]
+	set tcprew($i) [new Agent/TCP/WestwoodNR]
+	$tcp($i) set filter_type_ 4
+	$tcprew($i) set filter_type_ 4
+	$tcp($i) set tau_ 1
+	$tcprew($i) set tau_ 1
+	$tcp($i) set west_type_ 3
+	$tcprew($i) set west_type_ 3
+	$tcp($i) set interp_type_ 0
+	$tcprew($i) set interp_type_ 0
+
+       }
+       "vegas"  {
+        set tcp($i) [new Agent/TCP/Vegas]
+	set tcprew($i) [new Agent/TCP/Vegas]
+
+       }
+ 		}
+
+
+ 	$tcp($i) set window_ 10000
+        $tcp($i) set maxcwnd_ 10000
+        $tcp($i) set windowInit_ 1
+	$tcp($i) set packetSize_ 1500
+	$tcp($i) set windowInitOption_ 2
+	
+       	#$tcp($i) set timestamps_ 1
+	$ns attach-agent $nsender($i) $tcp($i)
+	set ftp($i) [new Application/FTP]
+
+	set sink($i) [new Agent/TCPSink/DelAck]
+	$ns attach-agent $nrecv($i) $sink($i)
+
+	$ns connect $tcp($i) $sink($i)
+	$ftp($i) attach-agent $tcp($i)
+
+	#the start time of the cross connection is uniformly distributed in the range [0,500]
+	set k [$u value]
+	$ns at $k "$ftp($i) start"
+	#puts "$k"
+	
+	#the stop time of the cross connection is uniformly distributed in the range [500,1000]
+	set k [$u1 value]
+	$ns at $k "$ftp($i) stop"
+	#puts "$k"
+
+	#$ns at 0.0 "$ftp($i) start"
+
+	$tcprew($i) set window_ 1000
+        $tcprew($i) set maxcwnd_ 1000
+        $tcprew($i) set windowInit_ 1
+	$tcprew($i) set packetSize_ 1500
+	$tcprew($i) set windowInitOption_ 2
+	
+      #  $tcprew($i) set timestamps_ 1
+	$ns attach-agent $nsenderrew($i) $tcprew($i)
+	set ftprew($i) [new Application/FTP]
+
+	set sinkrew($i) [new Agent/TCPSink/DelAck]
+	$ns attach-agent $nrecvrew($i) $sinkrew($i)
+
+	$ns connect $tcprew($i) $sinkrew($i)
+	$ftprew($i) attach-agent $tcprew($i)
+
+	set k [$u value]
+	$ns at $k "$ftprew($i) start"
+	#puts "$k"
+
+	set k [$u1 value]
+	$ns at $k "$ftprew($i) stop"
+	#puts "$k"
+
+
+	#$ns at 0.0 "$ftprew($i) start"
+
+	}
+
+
+# definizione del modello d'errore
+set good [new ErrorModel]
+$good unit pkt
+$good set rate_ $perdite
+#set rv0 [new RandomVariable/Uniform]
+#$rv0 set avg_ 0.01
+#$good ranvar $rv0
+
+
+set bad [new ErrorModel]
+$bad unit pkt
+$bad set rate_   $perdite
+#set rv1 [new RandomVariable/Uniform]
+#$rv1 set avg_ 0.07
+#$bad ranvar $rv1
+
+#rapporto tra i tempi good e bad 10:1
+set states [list $good $bad]
+#set periods [list 0.1 0.1]
+set periods [list 0.01 0.01]
+
+#set trans {{0.9875 0.0125} {0.025 0.975}}
+set trans {{0.5 0.5} {0.5 0.5}}
+
+set transunit pkt
+set sttype time
+set nstates 2
+set start $good
+set em1 [new ErrorModel/MultiState $states $periods $trans $transunit $sttype $nstates $start]
+set em2 [new ErrorModel/MultiState $states $periods $trans $transunit $sttype $nstates $start]
+$ns lossmodel $good $Receiver $Rlast
+$ns lossmodel $bad $Rlast $Receiver
+
+
+#Define a 'finish' procedure
+proc finish {} {
+	global node q0 cwndf snf nf ns bwef rttf sstf conn_type
+	#Close the output files
+	close $q0
+	close $cwndf
+	close $snf
+	close $bwef
+	close $rttf
+	close $sstf
+
+	$ns flush-trace
+
+	close $nf
+
+        exit 0
+}
+
+
+
+set coda 0
+#Define a procedure which periodically records the bandwidth received by the
+#three traffic sinks sink0/1/2 and writes it to the three files f0/1/2.
+proc record {} {
+        global ns coda sink0 sink1 sink2 q0 cwndf snf tcp mymonitor_ bwef rttf sstf conn_type hop tcpl stringa
+	#Get an instance of the simulator
+	#Set the time after which the procedure should be called again
+        set time 0.1
+
+        set now [$ns now]
+
+	set cwnd "$now"
+	set seq "$now"
+	#number of packets retransmitted by the cross traffic sources times 0.001
+	set somma 0
+	#sum of the sequence numbers of the cross traffic sources times 0.001
+	set sommag 0
+	set bwe "$now"
+	set rttF "$now"
+	set sst "$now"
+
+	
+	for {set i 0} {$i < $hop} {incr i} {
+
+	set num [expr ([$tcp($i) set nrexmitpack_]*0.001)]
+
+	set numg [expr ([$tcp($i) set t_seqno_])*0.001]
+
+
+	set somma [expr ($somma + $num)]
+
+	set sommag [expr ($sommag + $numg)]
+
+
+	 }
+
+
+	set cwnd "$cwnd [$tcpl set cwnd_]"
+
+	set seq "$seq [$tcpl set t_seqno_]"
+	#packets retransmitted by the connection traversion all the hops
+	set retlong [$tcpl set nrexmitpack_]
+	#seq. no. of the connection traversing all the hops
+	set goodputlong [$tcpl set t_seqno_]
+
+	set rttF "$rttF [$tcpl set rtt_]"
+
+	set sst "$sst [$tcpl set ssthresh_]"
+
+	switch $conn_type {
+
+     		   "westwood"  {
+
+    	set bwe "$bwe [$tcpl set current_bwe_]"
+
+		}
+	}
+
+
+	puts $cwndf "$cwnd"
+    	puts $snf "$seq"
+    	puts $bwef "$bwe"
+    	puts $rttf "$rttF"
+    	puts $sstf "$sst"
+
+    	if {$now>=999.9} {
+    	puts "$stringa $goodputlong $retlong $sommag $somma"
+    	}
+    	
+    	
+	#Reset the bytes_ values on the traffic sinks
+
+	#Re-schedule the procedure
+        $ns at [expr $now+$time] "record"
+}
+
+
+#Create three traffic sinks and attach them to the node n4
+
+
+#Create three traffic sources
+
+
+#Start logging the received bandwidth
+$ns at 0.0 "record"
+
+$ns at 1000.0 "finish"
+
+#Run the simulation
+$ns run
diff -rupN ns-2.29/westwood/ns2_default.txt ns-2.29-click-scheduler/westwood/ns2_default.txt
--- ns-2.29/westwood/ns2_default.txt	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/westwood/ns2_default.txt	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,34 @@
+# Added for TCP WestwoodNR
+
+Agent/TCP/WestwoodNR set openadd_ 1
+Agent/TCP/WestwoodNR set current_bwe_ 0
+Agent/TCP/WestwoodNR set last_bwe_sample_ 0
+Agent/TCP/WestwoodNR set unaccounted_ 0
+Agent/TCP/WestwoodNR set fr_a_ 1
+Agent/TCP/WestwoodNR set min_rtt_estimate 10000
+Agent/TCP/WestwoodNR set myseqno_ 1
+
+Agent/TCP/WestwoodNR set lastackno_ 0
+Agent/TCP/WestwoodNR set lastackrx_ 0
+Agent/TCP/WestwoodNR set fr_alpha_ 0.9
+Agent/TCP/WestwoodNR set filter_type_ 4
+Agent/TCP/WestwoodNR set tau_ 1.0
+Agent/TCP/WestwoodNR set west_type_ 3.0
+Agent/TCP/WestwoodNR set qest_ 0.0
+Agent/TCP/WestwoodNR set fr_amin_ 0.0
+Agent/TCP/WestwoodNR set fr_amax_ 0.0
+Agent/TCP/WestwoodNR set total_time_ 0.0
+Agent/TCP/WestwoodNR set total_size_ 0.0
+Agent/TCP/WestwoodNR set interp_type_ 0.0
+Agent/TCP/WestwoodNR set fr_prev_ 1.0
+Agent/TCP/WestwoodNR set last_seq_ 0
+Agent/TCP/WestwoodNR set last_echoed_ts_ 0.0
+Agent/TCP/WestwoodNR set last_ts_ 0.0
+Agent/TCP/WestwoodNR set last_cwnd_ 1.0
+
+Agent/TCP/WestwoodNR set current_ts_ 0.0
+Agent/TCP/WestwoodNR set current_echoed_ts_ 0.0
+Agent/TCP/WestwoodNR set newreno_changes_ 0
+Agent/TCP/WestwoodNR set newreno_changes1_ 0
+Agent/TCP/WestwoodNR set partial_window_deflation_ 0
+Agent/TCP/WestwoodNR set exit_recovery_fix_ 0
diff -rupN ns-2.29/westwood/singlebottleneck.tcl ns-2.29-click-scheduler/westwood/singlebottleneck.tcl
--- ns-2.29/westwood/singlebottleneck.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/westwood/singlebottleneck.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,347 @@
+#select the forward traffic type: reno, westwood or vegas
+set conn_type [lindex $argv 0]
+#select the number of sources sharing the bottleneck on the forward path, the number of sources is equal to $node-3
+set node [lindex $argv 1]
+#select the capacity of the bottleneck
+set bw [lindex $argv 2]
+#select the time constant of the filter used by westwood (1.0 is a reasonable setting)
+set tau [lindex $argv 3]
+#the bottleneck queueu size is equal to $q times the bandwidth delay product
+set q [lindex $argv 4]
+#select the number of sources sharing the bottleneck on the backward path,the number of sources is equal to $rev-3
+set rev [lindex $argv 5]
+#select the filter used by westwood (set $filt=4 to simulate westwood+, $filt=3 to simulate westwood)
+set filt [lindex $argv 6]
+#the maximum, RTT is equal to 250ms times $rtt
+set rtt [lindex $argv 7]
+#packet loss probability that affects the bottleneck on both forward and backward directions
+set loss [lindex $argv 8]
+
+#puts "$conn_type $node $bw $th $wt $fmin $fmax $tau $interp $q $rev $filt $rtt $loss $alpha"
+
+
+
+#Create a simulator object
+set ns [new Simulator]
+
+#Open the output files
+set q0 [open q.tr w]
+#congestion window values of the forward connections
+set cwndf [open cwnd.tr w]
+#sequence numbers of the forward connections
+set snf [open sn.tr w]
+#bandwidth estimates of the forward connections
+set bwef [open bwe.tr w]
+#rtts measuered by the forward connections
+set rttf [open rtt.tr w]
+#slow start thtreshold of the forward connections
+set sstf [open sst.tr w]
+
+set buffer [expr round((($bw*250000*$q*$rtt)/(1500*8)))]
+set bw [expr ($bw*1000000)]
+
+#if you want to set up a minimum bound on the bottleneck queue length uncomment the following 3 lines
+#if ($buffer<20) {
+#	set buffer 20
+#		 }
+
+#uncomment the following 2 lines if you want to ontain the ns trace files at the end of the simulation
+set nf [open out.nam w]
+#$ns namtrace-all $nf
+set f [open out.tr w]
+#$ns trace-all $f
+
+#Create the nodes
+for {set i 0} {$i < $node} {incr i} {
+        set n($i) [$ns node]
+        set nend($i) [$ns node]
+
+}
+
+for {set i 0} {$i < $rev} {incr i} {
+      set nrew($i) [$ns node]
+      set nendrew($i) [$ns node]
+
+}
+
+set delaybott [expr (0.005*$rtt)]
+$ns duplex-link $n(2) $n(1) $bw $delaybott DropTail
+
+$ns queue-limit $n(2) $n(1) $buffer
+$ns queue-limit $n(1) $n(2) $buffer
+
+
+#$ns duplex-link $n(1) $n(0) 1000Mb 1ms DropTail
+#$ns queue-limit $n(1) $n(0) 10000000
+#$ns queue-limit $n(0) $n(1) 100000000
+
+# error model
+set good [new ErrorModel]
+$good unit pkt
+$good set rate_ $loss
+#set rv0 [new RandomVariable/Uniform]
+#$rv0 set avg_ 0.01
+#$good ranvar $rv0
+
+set bad [new ErrorModel]
+$bad unit pkt
+$bad set rate_   $loss
+#set rv1 [new RandomVariable/Uniform]
+#$rv1 set avg_ 0.07
+#$bad ranvar $rv1
+
+#rapporto tra i tempi good e bad 10:1
+set states [list $good $bad]
+#set periods [list 0.1 0.1]
+set periods [list 0.01 0.01]
+
+#set trans {{0.9875 0.0125} {0.025 0.975}}
+#set trans {{0.5 0.5} {0.5 0.5}}
+
+#set transunit pkt
+#set sttype time
+#set nstates 2
+#set start $good
+#set em1 [new ErrorModel/MultiState $states $periods $trans $transunit $sttype $nstates $start]
+#set em2 [new ErrorModel/MultiState $states $periods $trans $transunit $sttype $nstates $start]
+$ns lossmodel $good $n(2) $n(1)
+$ns lossmodel $bad $n(1) $n(2)
+
+
+set mymonitor_ [$ns monitor-queue $n(2) $n(1) size_]
+
+#RTTs are uniformly spread from 10ms+240ms/($node-3) to 250ms
+set delta [expr ($rtt*0.06)/($node-3)]
+
+#Create links between the nodes
+for {set i 3} {$i < $node} {incr i} {
+
+	set delay [expr ($i-2)*$delta]
+        $ns duplex-link $n($i) $n(2) 1000Mb $delay DropTail
+	$ns queue-limit $n($i) $n(2) 1000000
+        $ns queue-limit $n(2) $n($i) 1000000
+
+        switch $conn_type {
+    "reno" {
+         set tcp($i) [new Agent/TCP/Newreno]
+         }
+    "westwood"  {
+        set tcp($i) [new Agent/TCP/WestwoodNR]
+       }
+       "vegas"  {
+        set tcp($i) [new Agent/TCP/Vegas]
+       }
+ }
+    	$tcp($i) set window_ 10000
+        $tcp($i) set maxcwnd_ 10000
+        $tcp($i) set windowInit_ 1
+	$tcp($i) set packetSize_ 1500
+	$tcp($i) set filter_type_ $filt
+	$tcp($i) set tau_ $tau
+	$tcp($i) set fr_alpha_ 0.9
+	#$tcp($i) set fr_a_ $th
+	$tcp($i) set fr_amin_ 10000
+	$tcp($i) set fr_amax_ 10000
+	$tcp($i) set west_type_ 3
+	$tcp($i) set useHeaders_ 0
+	$tcp($i) set interp_type_ 0
+	#$tcp($i) set timestamps_ 1
+	$tcp($i) set windowInitOption_ 2
+	$tcp($i) set newreno_changes_ 0
+	$tcp($i) set newreno_changes1_ 0
+	$tcp($i) set tcpTick_ 0.01
+
+	$ns attach-agent $n($i) $tcp($i)
+	set ftp($i) [new Application/FTP]
+
+
+ }
+
+
+
+
+for {set i 3} {$i < $node} {incr i} {
+	
+
+	set delay [expr ($i-2)*$delta]
+        $ns duplex-link $nend($i) $n(1) 1000Mb $delay DropTail
+	$ns queue-limit $nend($i) $n(1) 1000000
+        $ns queue-limit $n(1) $nend($i) 1000000
+
+	#set sink($i) [new Agent/TCPSink/DelAck]
+
+	set sink($i) [new Agent/TCPSink]
+	$ns attach-agent $nend($i) $sink($i)
+
+	$ns connect $tcp($i) $sink($i)
+	$ftp($i) attach-agent $tcp($i)
+	$ns at 0.0 "$ftp($i) start"
+ }
+
+ for {set i 3} {$i < $rev} {incr i} {
+
+
+
+	set delay [expr ($i-2)*$delta]
+        $ns duplex-link $nrew($i) $n(1) 1000Mb $delay DropTail
+	$ns queue-limit $nrew($i) $n(1) 1000000
+        $ns queue-limit $n(1) $nrew($i) 1000000
+
+        switch $conn_type {
+    "reno" {
+         set tcprew($i) [new Agent/TCP/Newreno]
+         }
+    "westwood"  {
+        set tcprew($i) [new Agent/TCP/WestwoodNR]
+       }
+       "vegas"  {
+        set tcprew($i) [new Agent/TCP/Vegas]
+       }
+ }
+
+	#set tcprew($i) [new Agent/TCP/Newreno]
+
+	$tcprew($i) set window_ 1000
+        $tcprew($i) set maxcwnd_ 1000
+        $tcprew($i) set windowInit_ 1
+	$tcprew($i) set packetSize_ 1500
+	$tcprew($i) set filter_type_ $filt
+	$tcprew($i) set tau_ $tau
+	$tcprew($i) set fr_alpha_ 0.9
+	#$tcprew($i) set fr_a_ $th
+	$tcprew($i) set fr_amin_ 10000
+	$tcprew($i) set fr_amax_ 10000
+	$tcprew($i) set west_type_ 3
+	$tcprew($i) set useHeaders_ 0
+	$tcprew($i) set interp_type_ 0
+
+#	$tcprew($i) set timestamps_ 1
+	$tcprew($i) set windowInitOption_ 2
+
+
+
+
+	$ns attach-agent $nrew($i) $tcprew($i)
+	set ftprew($i) [new Application/FTP]
+
+
+ }
+
+ for {set i 3} {$i < $rev} {incr i} {
+
+
+	set delay [expr ($i-2)*$delta]
+        $ns duplex-link $nendrew($i) $n(2) 1000Mb $delay DropTail
+	$ns queue-limit $nendrew($i) $n(2) 1000000
+        $ns queue-limit $n(2) $nendrew($i) 1000000
+
+	set sinkrew($i) [new Agent/TCPSink/DelAck]
+
+	$ns attach-agent $nendrew($i) $sinkrew($i)
+
+	$ns connect $tcprew($i) $sinkrew($i)
+	$ftprew($i) attach-agent $tcprew($i)
+	$ns at 0.0 "$ftprew($i) start"
+ }
+
+
+
+#Define a 'finish' procedure
+proc finish {} {
+	global node q0 cwndf snf nf ns bwef rttf sstf
+	#Close the output files
+	close $q0
+	close $cwndf
+	close $snf
+	close $bwef
+	close $rttf
+	close $sstf
+
+	$ns flush-trace
+
+	close $nf
+
+        exit 0
+}
+
+
+set coda 0
+#Define a procedure which periodically records the bandwidth received by the
+#three traffic sinks sink0/1/2 and writes it to the three files f0/1/2.
+proc record {} {
+        global ns bw coda sink0 sink1 sink2 q0 cwndf snf tcp mymonitor_ node bwef  rttf sstf rttmf conn_type bwevf bw tau q rev filt rtt loss alpha
+
+	#Set the time after which the procedure should be called again
+        set time 0.1
+
+        set now [$ns now]
+	#Calculate the bandwidth (in MBit/s) and write it to the files
+	set cwnd "$now"
+	set seq "$now"
+	#somma represents the total number of retransmitted packets times 0.001
+	set somma 0
+	set sommaq 0
+	#sommag represents the sum of the sequence numbers of all the sources times 0.001
+	set sommag 0
+	set sommaqg 0
+	set bwe "$now"
+	set data "$now"
+	set ack "$now"
+	set rttF "$now"
+	set sst "$now"
+
+	for {set i 3} {$i < $node} {incr i} {
+
+	set cwnd "$cwnd [$tcp($i) set cwnd_]"
+   	set seq "$seq [$tcp($i) set t_seqno_]"
+ 	set num [expr ([$tcp($i) set nrexmitpack_]*0.001)]
+	set numg [expr ([$tcp($i) set t_seqno_])*0.001]
+	set somma [expr ($somma + $num)]
+	set sommag [expr ($sommag + $numg)]
+	set sommaqg [expr ($sommaqg + $numg*$numg)]
+	set rttF "$rttF [$tcp($i) set rtt_]"
+	set sst "$sst [$tcp($i) set ssthresh_]"
+	
+	switch $conn_type {
+     		   "westwood"  {
+    	set bwe "$bwe [$tcp($i) set current_bwe_]"
+
+			}
+ 	}
+
+
+ }
+
+	if ($sommag>0) {
+	#comupte the fairness index
+	set indexg [expr ($sommag*$sommag/($sommaqg*($node-3)))]
+
+	}
+
+	set size  [$mymonitor_ set size_]
+	set size [expr ($size/1500)]
+      	puts $q0 "$now $size"
+	set coda [expr ($coda+$size/1000)]
+
+        puts $cwndf "$cwnd"
+	# puts $cwndf "$now $sommacwnd"
+    	puts $snf "$seq"
+    	puts $bwef "$bwe"
+
+    	puts $rttf "$rttF"
+    	puts $sstf "$sst"
+
+    	if {$now>=999.9} {
+    	puts "$conn_type $node $bw $tau $q $rev $filt $rtt $loss $indexg $somma $sommag [expr ($coda)]"
+    	}
+
+	$ns at [expr $now+$time] "record"
+}
+
+#Start logging the received bandwidth
+$ns at 0.0 "record"
+
+$ns at 1000.0 "finish"
+
+#Run the simulation
+$ns run
diff -rupN ns-2.29/westwood/tcp-westwood-nr.cc ns-2.29-click-scheduler/westwood/tcp-westwood-nr.cc
--- ns-2.29/westwood/tcp-westwood-nr.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/westwood/tcp-westwood-nr.cc	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,842 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1990, 2001 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Lawrence Berkeley Laboratory,
+ * Berkeley, CA.  The name of the University may not be used to
+ * endorse or promote products derived from this software without
+ * specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef lint
+static const char rcsid[] =
+    "@(#) $Header: /mvalla/tcp-w-nr.cc,v 1.2 2001/09/17 15:12:29 mvalla Exp mvalla $ (LBL)";
+#endif
+
+//
+// tcp-w-nr: a revised New Reno TCP source, with faster recovery
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <math.h>
+
+#include "packet.h"
+#include "ip.h"
+#include "tcp.h"
+#include "flags.h"
+#include "address.h"
+
+#include "tcp-westwood-nr.h"
+
+static class WestwoodNRTcpClass : public TclClass {
+public:
+	WestwoodNRTcpClass() : TclClass("Agent/TCP/WestwoodNR") {}
+	TclObject* create(int, const char*const*) {
+		return (new WestwoodNRTcpAgent());
+	}
+} class_westwoodnr;
+
+///// 
+// WestwoodNRTcpAgent()
+WestwoodNRTcpAgent::WestwoodNRTcpAgent() : NewRenoTcpAgent(),
+  // these where originally in TcpAgent()
+  current_bwe_(0), last_bwe_sample_(0), unaccounted_(0),
+  fr_a_(0), min_rtt_estimate(5.0), myseqno_(1),last_ts_(0),last_echoed_ts_(0),last_seq_(0),
+  lastackrx_(0.0), fr_alpha_(0.9), filter_type_(1), tau_(1.0), total_time_(0.0), total_size_(0.0), fr_prev_(20.0)
+
+{
+	// Read defaults variables from ns-defaults.tcl
+
+	// these where originally in TcpAgent()
+	
+	bind("current_bwe_", &current_bwe_);
+	bind("last_bwe_sample_", &last_bwe_sample_);
+  	bind("unaccounted_", &unaccounted_);
+  	bind("fr_a_", &fr_a_);
+	bind("fr_amin_", &fr_amin_);
+	bind("fr_amax_", &fr_amax_);
+	bind("fr_prev_", &fr_prev_);
+  	bind("min_rtt_estimate", &min_rtt_estimate);
+
+	bind("fr_alpha_", &fr_alpha_);
+	bind("filter_type_", &filter_type_);
+	bind("tau_", &tau_);
+	bind("west_type_",&west_type_);
+	bind("qest_",&qest_);
+	bind("total_time_",&total_time_);
+	bind("total_size_",&total_size_);
+	bind("interp_type_",&interp_type_);
+
+	bind("last_ts_",&last_ts_);
+	bind("last_echoed_ts_",&last_echoed_ts_);
+	bind("last_seq_",&last_seq_);
+	bind("last_cwnd_",&last_cwnd_);
+	bind("current_ts_",&current_ts_);
+	bind("current_echoed_ts_",&current_echoed_ts_);
+
+	// these where originally in NewRenoTcpAgent()
+	bind("newreno_changes_", &newreno_changes_);
+	bind("newreno_changes1_", &newreno_changes1_);
+	bind("exit_recovery_fix_", &exit_recovery_fix_);
+	bind("partial_window_deflation_", &partial_window_deflation_);
+	bind("openadd_", &openadd_);
+	//printf("Westwood New Reno binding done!\n");
+}
+
+///// 
+// dupack_action()
+void WestwoodNRTcpAgent::dupack_action()
+{
+	int recovered = (highest_ack_ > recover_);
+        int allowFastRetransmit = allow_fast_retransmit(last_cwnd_action_);
+        if (recovered || (!bug_fix_ && !ecn_) || allowFastRetransmit) {
+                goto reno_action;
+        }
+
+        if (ecn_ && last_cwnd_action_ == CWND_ACTION_ECN) {
+                last_cwnd_action_ = CWND_ACTION_DUPACK;
+                /*
+                 * What if there is a DUPACK action followed closely by ECN
+                 * followed closely by a DUPACK action?
+                 * The optimal thing to do would be to remember all
+                 * congestion actions from the most recent window
+                 * of data.  Otherwise "bugfix" might not prevent
+                 * all unnecessary Fast Retransmits.
+                 */
+                reset_rtx_timer(1,0);
+                output(last_ack_ + 1, TCP_REASON_DUPACK);
+                return;
+        }
+
+        if (bug_fix_) {
+                /*
+                 * The line below, for "bug_fix_" true, avoids
+                 * problems with multiple fast retransmits in one
+                 * window of data.
+                 */
+                return;
+        }
+
+reno_action:
+
+/*    
+     if (ssthresh_ > cwnd_) {
+	fr_a_+=0.25;
+	if (fr_a_ > 4)
+	  fr_a_=4;
+      } else {
+	fr_a_ = 1;
+      }
+  	ssthresh_ = (int)((current_bwe_/size_/8) * min_rtt_estimate);
+      	if (cwnd_ > ssthresh_) {
+      		cwnd_ = ssthresh_;
+      	}
+	*/
+
+double fr_now = Scheduler::instance().clock();
+double rtt_estimate = t_rtt_ * tcp_tick_;
+
+if ((rtt_estimate < min_rtt_estimate)&&(rtt_estimate > 0)) {
+		   min_rtt_estimate = rtt_estimate;
+		}
+
+
+/* west_type_ = 3 west+
+   */
+
+
+
+//if (west_type_<=4)fr_a_=-1;
+
+double sstemp=(((current_bwe_*(min_rtt_estimate))/((double)(size_*8.0))));
+
+if (sstemp < 2) sstemp = 2;
+//if (sstemp1 < 2) sstemp1 = 2;
+
+
+		ssthresh_ = (int)(sstemp);
+
+		if (cwnd_ > sstemp) {cwnd_ = sstemp;}
+
+
+
+	trace_event("TCPWNR_FAST_RETX");
+        recover_ = maxseq_;
+        last_cwnd_action_ = CWND_ACTION_DUPACK;
+        // The slowdown was already performed
+        // slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_HALF);
+        reset_rtx_timer(1,0);
+        output(last_ack_ + 1, TCP_REASON_DUPACK);
+        return;
+
+}
+
+/////
+// timeout()
+void WestwoodNRTcpAgent::timeout(int tno)
+{
+
+	/* retransmit timer */
+	if (tno == TCP_TIMER_RTX) {
+		if (highest_ack_ == maxseq_ && !slow_start_restart_) {
+			/*
+			 * TCP option:
+			 * If no outstanding data, then don't do anything.
+			 */
+			return;
+		};
+		recover_ = maxseq_;
+		if (highest_ack_ == -1 && wnd_init_option_ == 2)
+			/* 
+			 * First packet dropped, so don't use larger
+			 * initial windows. 
+			 */
+			wnd_init_option_ = 1;
+		if (highest_ack_ == maxseq_ && restart_bugfix_)
+		       /* 
+			* if there is no outstanding data, don't cut 
+			* down ssthresh_.
+			*/
+			slowdown(CLOSE_CWND_ONE);
+		else if (highest_ack_ < recover_ &&
+		  last_cwnd_action_ == CWND_ACTION_ECN) {
+		       /*
+			* if we are in recovery from a recent ECN,
+			* don't cut down ssthresh_.
+			*/
+			slowdown(CLOSE_CWND_ONE);
+		}
+		else {
+			++nrexmit_;
+			slowdown(CLOSE_FASTER);
+		}
+		/* if there is no outstanding data, don't back off rtx timer */
+		if (highest_ack_ == maxseq_ && restart_bugfix_) {
+			reset_rtx_timer(0,0);
+		}
+		else {
+			reset_rtx_timer(0,1);
+		}
+		last_cwnd_action_ = CWND_ACTION_TIMEOUT;
+		send_much(0, TCP_REASON_TIMEOUT, maxburst_);
+
+	} 
+	else {
+		timeout_nonrtx(tno);
+	}
+}
+
+///// 
+// bwe_computation()
+void WestwoodNRTcpAgent::bwe_computation(Packet *pkt) {
+	
+	hdr_tcp *tcph = hdr_tcp::access(pkt);
+	double fr_now = Scheduler::instance().clock();
+	hdr_flags *fh = hdr_flags::access(pkt);
+	
+	// last_ack_ indicates the ack no. of the ack received _before_
+	// the current one 
+	
+	// START BWE COMPUTATION
+  // Idea: cumulative ACKs acking more than 2 packets count for 1 packet
+	//   since DUPACKs have already been accounted for
+	int cumul_ack = tcph->seqno_ - last_ack_;
+	int cumul_ack1 = cumul_ack; //used for queueing time estimation
+	myseqno_ = tcph->seqno_;
+
+	if (cumul_ack > 1) {
+
+	  /* check if current ACK ACKs fewer or same number of segments than */
+	  /* expected: if so, the missing ones were already accounted for by */
+	  /* DUPACKs, and current ACK only counts as 1 */
+	  if (unaccounted_ >= cumul_ack) {
+	    unaccounted_-=cumul_ack;
+	    cumul_ack=1;
+	  } else
+	  /* check if current ACK ACKs more segments than expected: if so,   */
+	  /* part of them were already accounted for by DUPACKs; the rest    */
+
+	  /* are cumulatively ACKed by present ACK. Make present ACK count   */
+	  /* as the unacknowledged ACKs in excess*/
+	  if (unaccounted_ < cumul_ack) {
+	    cumul_ack-=unaccounted_;
+	    unaccounted_=0;
+	  }
+	}
+
+  /* if cumul_ack=0, the current ACK is clearly a DUPACK and should */
+	/* count 1 */
+	if (cumul_ack == 0) {
+	  unaccounted_++;
+	  cumul_ack=1;
+	}
+
+  /* safety check; if the previous steps are followed exactly,      */
+	/* cumul_ack should not be >2 unless some strage events occur     */
+	/* (e.g., an ACK is dropped on the way back and the following one */
+	/* appears to ACK more than its due)                              */
+
+	if (cumul_ack > 2) {
+	  cumul_ack=2;
+	  }
+
+
+
+	nackpack_+= cumul_ack;
+	last_seq_+=cumul_ack;
+	//qest_=cwnd_-(current_bwe_*min_rtt_estimate)/(8.0*(double)size_);
+
+	current_ts_=tcph->ts();
+	current_echoed_ts_=tcph->ts_echo();
+
+	double rtt_estimate = t_rtt_ * tcp_tick_;
+	
+	
+
+	  if ((rtt_estimate < min_rtt_estimate)&&(rtt_estimate > 0)) {
+		  min_rtt_estimate = rtt_estimate;
+		qest_=0;
+ 		last_echoed_ts_=current_echoed_ts_;
+ 		last_ts_=current_ts_;
+		}
+
+		qest_=qest_+(current_ts_-last_ts_)-(current_echoed_ts_-last_echoed_ts_);
+		last_echoed_ts_=current_echoed_ts_;
+ 		last_ts_=current_ts_;
+
+
+//if (west_type_==5) qest_=cwnd_-(current_bwe_*min_rtt_estimate)/(8.0*(double)size_);
+
+
+
+	int acked_size = size_ * 8 * cumul_ack;
+	double ack_interv = fr_now - lastackrx_;
+	double sample_bwe;
+	double last_tmp_bwe;
+	int idle_intervals;
+
+	switch (filter_type_) {
+	  case 0:
+          //   original filter
+	  sample_bwe = acked_size/ack_interv;
+	  current_bwe_ = current_bwe_ * fr_alpha_ + sample_bwe * (1 - fr_alpha_);
+	  last_bwe_sample_ = sample_bwe;
+	  break;
+
+	  case 1:
+	  // filter type 1
+	  sample_bwe = acked_size/ack_interv;
+	  current_bwe_ = current_bwe_ * .9047 +
+	               (sample_bwe + last_bwe_sample_) * .0476;
+	last_bwe_sample_ = sample_bwe;
+	  break;
+	
+	  case 2:
+	  // filter type 2: 'lower' pass
+	  sample_bwe = acked_size/ack_interv;
+	  current_bwe_ = current_bwe_ * .93548 + 
+	               (sample_bwe+last_bwe_sample_) * .03225;
+
+	  last_bwe_sample_ = sample_bwe;
+	  break;
+
+	  case 3:
+	  // filter type 3: time constant tau_
+
+	  // compute how many intervals of length tau_/2 went by since we
+	  // received the last ACK. For each tau_/2 interval without ACK, feed
+          // a zero-bandwidth sample to the filter.
+
+	  idle_intervals = (int)(ack_interv / tau_*2.0);
+	  //	  printf("idle_intervals = %d (%f,%f)=%f\n", idle_intervals, ack_interv, tau_,
+	  //				ack_interv / tau_);
+	  //		printf("idle_intervals = %d, ratio= %f\n",idle_intervals, ack_interv / tau_);
+	  
+	  ack_interv -= tau_ /2.0 * idle_intervals;
+	  
+	  //if ( (ack_interv < 0.01) && (idle_intervals == 0) ){
+	  //	printf("TCP-W error: (ack_interv < 0.01) && (idle_intervals == 0)\n");
+	  //	printf("time=%lf, last_ack=%lf, ack_interv=%lf\n", fr_now, lastackrx_, ack_interv);
+	  //	//exit(0);
+	  //}	
+	  
+	  if ( (ack_interv < 0.01) && (idle_intervals > 0) ) {
+	  // ack_interv was a multiple of tau_/2 or the remainder is too small (less than 10ms), so 
+	  // we consider tau_ / 2 as the last interval
+	  	ack_interv = tau_ / 2.0;
+		idle_intervals -= 1; // we do not count the last tau_/2 interval
+	  }
+	  
+	  sample_bwe = acked_size/ack_interv;
+	  
+	  if (idle_intervals > 0) { // feed the filter
+	  	// printf("idle_intervals = %d\n", idle_intervals);
+		for (int i=0; i<idle_intervals; i++) {
+			current_bwe_ = current_bwe_ * 3.0 / 5.0  + last_bwe_sample_/5.0;
+			last_bwe_sample_ = 0.0;
+			//  printf("idle_interval: current_bwe=%f\n", current_bwe_);
+		}
+	  }
+	  
+	  last_tmp_bwe = current_bwe_; // we need it just for the printf...
+	  current_bwe_ = current_bwe_ * (2.0*tau_-ack_interv) /
+		           (2.0*tau_+ack_interv) +
+		           ack_interv*(sample_bwe + last_bwe_sample_)/(2.0*tau_+ack_interv);
+
+	last_bwe_sample_ = sample_bwe;
+
+	  if (current_bwe_ < 0) {
+			printf("TCP-W error: current_bwe_ < 0\n");
+			printf("time: %f, last_tmp_bwe=%f\n", fr_now, last_tmp_bwe);
+			printf("current_bwe_%f, ack_interv=%f, sample_bwe=%f, last_bwe_sample_=%f\n",
+					current_bwe_, ack_interv, sample_bwe, last_bwe_sample_);
+			exit(0);
+	  }
+	  break;
+
+	  case 4:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+
+        sample_bwe = total_size_/total_time_;
+
+	double m=(sample_bwe-last_bwe_sample_)/pow(total_time_,interp_type_);
+
+	double sample_bwe_new=sample_bwe;
+	double sample_bwe_old=last_bwe_sample_;
+	double ack_delta=ack_interv;
+
+
+	int Num_cicli;
+	if (total_time_ < tau_/4.0) {
+		Num_cicli = 0;
+		ack_interv=total_time_;
+		}
+		else {
+		Num_cicli = (int)(floor(((4.0*total_time_)/tau_)));
+		ack_interv = total_time_-0.25*tau_*((double)(Num_cicli));
+		}
+
+
+		int i1;
+  	for (i1=0;i1<(Num_cicli); i1++) 	{
+
+		//if (m<0) {
+			//sample_bwe=sample_bwe_old+m*pow((i1*tau_/4.0),interp_type_);
+		//	}
+
+		current_bwe_ = current_bwe_*(7.0/9.0)+(sample_bwe+last_bwe_sample_)/9.0;
+		last_bwe_sample_ = sample_bwe;
+		}
+
+		if (ack_interv>0) {
+		current_bwe_ = current_bwe_ * (2.0*tau_-ack_interv)/(2.0*tau_+ack_interv) +
+		ack_interv*(sample_bwe_new+last_bwe_sample_)/(2.0*tau_+ack_interv);
+		last_bwe_sample_ = sample_bwe_new;
+		}
+
+
+
+
+	total_time_=0.0;
+	total_size_=0.0;
+	}
+	break;
+
+  case 5:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+
+        sample_bwe = total_size_/total_time_;
+
+	current_bwe_=current_bwe_ * fr_alpha_ + sample_bwe*(1.0 - fr_alpha_);
+
+	last_bwe_sample_ = sample_bwe;
+
+	total_time_=0;
+	total_size_=0;
+	}
+		break;
+
+  case 6:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+
+        sample_bwe = total_size_/total_time_;
+	double sample_bwe1;
+	sample_bwe1=0.5*(sample_bwe+last_bwe_sample_);
+
+	current_bwe_=current_bwe_*fr_alpha_ + sample_bwe1*(1.0 - fr_alpha_);
+
+	last_bwe_sample_ = sample_bwe;
+
+	total_time_=0;
+	total_size_=0;
+	}
+	break;
+case 7:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+
+        sample_bwe = total_size_/total_time_;
+
+	double m=(sample_bwe-last_bwe_sample_)/pow(total_time_,interp_type_);
+
+	double sample_bwe_new=sample_bwe;
+	double sample_bwe_old=last_bwe_sample_;
+	double ack_delta=ack_interv;
+
+
+	int Num_cicli;
+	if (total_time_ < tau_/4.0) {
+		Num_cicli = 0;
+		ack_interv=total_time_;
+		}
+		else {
+		Num_cicli = (int)(floor(((4.0*total_time_)/tau_)));
+		ack_interv = total_time_-0.25*tau_*((double)(Num_cicli));
+		}
+
+
+		int i1;
+  	for (i1=0;i1<(Num_cicli); i1++) 	{
+
+
+		sample_bwe=sample_bwe_old+m*pow((i1*tau_/4.0),interp_type_);
+
+		current_bwe_ = current_bwe_*(7.0/9.0)+2.0*(sample_bwe)/9.0;
+		last_bwe_sample_ = sample_bwe;
+		}
+
+		if (ack_interv>0) {
+		current_bwe_ = current_bwe_ * (2.0*tau_-ack_interv)/(2.0*tau_+ack_interv) +
+		2.0*ack_interv*(sample_bwe_new)/(2.0*tau_+ack_interv);
+		last_bwe_sample_ = sample_bwe_new;
+		}
+
+
+
+
+	total_time_=0;
+	total_size_=0;
+	}
+
+break;
+
+  case 8:
+
+
+
+	sample_bwe = acked_size/ack_interv;
+
+	fr_alpha_=exp((-1.0*ack_interv/tau_));
+	current_bwe_=current_bwe_*fr_alpha_ + sample_bwe*(1.0 - fr_alpha_);
+
+	last_bwe_sample_ = sample_bwe;
+
+
+break;
+
+  case 9:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+
+        sample_bwe = total_size_/total_time_;
+	fr_alpha_=exp((-1.0*total_time_/tau_));
+	current_bwe_=current_bwe_*fr_alpha_ + sample_bwe*(1.0 - fr_alpha_);
+
+	last_bwe_sample_ = sample_bwe;
+
+	total_time_=0;
+	total_size_=0;
+	}
+	break;
+
+case 10:
+
+
+
+	total_size_ = total_size_ + acked_size;
+	total_time_ = total_time_ + ack_interv;
+
+	double ci;
+
+	if (((rtt_estimate >0)&&(total_time_>rtt_estimate))) {
+
+	//ci=cwnd_-(current_bwe_*min_rtt_estimate)/(8.0*(double)size_);
+
+	if (qest_ > fr_a_) sample_bwe = total_size_/total_time_;
+		else sample_bwe = last_bwe_sample_;
+
+	fr_alpha_=exp((-1.0*total_time_/tau_));
+	current_bwe_=current_bwe_*fr_alpha_ + sample_bwe*(1.0 - fr_alpha_);
+	last_bwe_sample_ = sample_bwe;
+	total_time_=0;
+	total_size_=0;
+	}
+
+
+
+
+} // end of filter_type switch
+
+
+
+
+double sstemp=(((current_bwe_*(min_rtt_estimate))/((double)(size_*8.0))));
+//double sstemp1=0.9*qest_+(((current_bwe_*(min_rtt_estimate))/((double)(size_*8.0))));
+
+
+
+#ifdef MYDEBUG
+	hdr_ip *iph = hdr_ip::access(pkt);  
+  	char *src_portaddr = Address::instance().print_portaddr(iph->sport());
+	printf("sc%s: ack. no. %d at time %f, bwe=%f, cwnd = %d, ssthresh_ = %d\n",
+	      src_portaddr, tcph->seqno_, fr_now, current_bwe_/1000000,
+	      (int)cwnd_, (int)ssthresh_);
+	printf("sc%s: now = %f, acked_size = %d, rxdiff = %f, last_ack_ = %d\n",
+	         src_portaddr, fr_now, acked_size, (fr_now - lastackrx_), last_ack_);
+	printf("sc%s: unaccounted_ = %d, fr_a_= %f, min_rtt_estimate = %f\n", 
+			     src_portaddr, unaccounted_, fr_a_, min_rtt_estimate);
+#endif
+#ifdef MYDEBUG_RTT
+	double f = t_rtt_ * tcp_tick_;
+	printf("source %s: %f cwnd=%d	      bwe=%f	  rtt=%f\n", 
+	      src_portaddr, fr_now, (int)cwnd_, current_bwe_/1000000, f);     
+#endif	
+#ifdef MYREPORT	
+	hdr_ip *iph = hdr_ip::access(pkt);  
+	char *src_portaddr = Address::instance().print_portaddr(iph->src());
+	printf("%s    %f      %d      %f      %d\n", 
+	      src_portaddr, fr_now, (int)cwnd_, current_bwe_/1000000,
+	      (int)ssthresh_);        
+#endif		
+
+	lastackrx_ = fr_now;
+}
+
+
+/////
+// recv()
+void WestwoodNRTcpAgent::recv(Packet *pkt, Handler* h)
+{
+	// START BWE COMPUTATION
+	bwe_computation(pkt);
+	//double cwndapp,sstreshapp;
+	//cwndapp=cwnd_;
+	//sstreshapp=ssthresh_;
+	NewRenoTcpAgent::recv(pkt,h);
+	/*if ((cwnd_>cwndapp)&&(cwndapp<sstreshapp))
+	{
+	cwnd_=cwnd_+openadd_; //a more aggressive slow start
+	send_much(0, 0, maxburst_);
+	}*/
+}
+
+/////////////////// Added by MV
+// these where originally in TcpAgent()
+
+/////
+// slowdown()
+void
+WestwoodNRTcpAgent::slowdown(int how)
+{
+	double win, halfwin, decreasewin;
+	int slowstart = 0;
+	double fr_now = Scheduler::instance().clock();
+	// we are in slowstart for sure if cwnd < ssthresh
+	if (cwnd_ < ssthresh_)
+		slowstart = 1;
+	// we are in slowstart - need to trace this event
+	trace_event("SLOW_START");
+
+        if (precision_reduce_) {
+		halfwin = windowd() / 2;
+                if (wnd_option_ == 6) {
+                        /* binomial controls */
+                        decreasewin = windowd() - (1.0-decrease_num_)*pow(windowd(),l_parameter_);
+                } else
+	 		decreasewin = decrease_num_ * windowd();
+		win = windowd();
+	} else  {
+		int temp;
+		temp = (int)(window() / 2);
+		halfwin = (double) temp;
+                if (wnd_option_ == 6) {
+                        /* binomial controls */
+                        temp = (int)(window() - (1.0-decrease_num_)*pow(window(),l_parameter_));
+                } else
+	 		temp = (int)(decrease_num_ * window());
+		decreasewin = (double) temp;
+		win = (double) window();
+	}
+	if (how & CLOSE_SSTHRESH_HALF)
+		// For the first decrease, decrease by half
+		// even for non-standard values of decrease_num_.
+		if (first_decrease_ == 1 || slowstart ||
+			last_cwnd_action_ == CWND_ACTION_TIMEOUT) {
+			// Do we really want halfwin instead of decreasewin
+			// after a timeout?
+			ssthresh_ = (int) halfwin;
+		} else {
+			ssthresh_ = (int) decreasewin;
+		}
+        else if (how & THREE_QUARTER_SSTHRESH)
+		if (ssthresh_ < 3*cwnd_/4)
+			ssthresh_  = (int)(3*cwnd_/4);
+	if (how & CLOSE_CWND_HALF)
+		// For the first decrease, decrease by half
+		// even for non-standard values of decrease_num_.
+		if (first_decrease_ == 1 || slowstart || decrease_num_ == 0.5) {
+			cwnd_ = halfwin;
+		} else cwnd_ = decreasewin;
+        else if (how & CWND_HALF_WITH_MIN) {
+		// We have not thought about how non-standard TCPs, with
+		// non-standard values of decrease_num_, should respond
+		// after quiescent periods.
+                cwnd_ = decreasewin;
+                if (cwnd_ < 1)
+                        cwnd_ = 1;
+	}
+	///
+	else if (how & CLOSE_FASTER) {
+    	// TCP Westwood
+	// this might be critical what with the coarseness of the timer;
+    	// keep in mind that TCP computes the timeout as
+    	//              (#of ticks) * (tick_duration)
+    	// We need to do away with the coarseness...
+
+
+	double rtt_estimate = t_rtt_ * tcp_tick_;
+
+	  if ((rtt_estimate <= min_rtt_estimate)&&(rtt_estimate > 0)) {
+		   min_rtt_estimate = rtt_estimate;
+		}
+
+	 double sstemp=(((current_bwe_*(min_rtt_estimate))/((double)(size_*8.0))));
+			if (sstemp < 2) sstemp = 2;
+			ssthresh_ = (int)(sstemp);
+			cwnd_ = 2;
+
+	}
+//printf("set timeout = %f%f\n", fr_now,ssthresh_);
+
+
+	else if (how & CLOSE_CWND_RESTART)
+		cwnd_ = int(wnd_restart_);
+	else if (how & CLOSE_CWND_INIT)
+		cwnd_ = int(wnd_init_);
+	else if (how & CLOSE_CWND_ONE)
+		cwnd_ = 1;
+	else if (how & CLOSE_CWND_HALF_WAY) {
+		// cwnd_ = win - (win - W_used)/2 ;
+		cwnd_ = W_used + decrease_num_ * (win - W_used);
+                if (cwnd_ < 1)
+                        cwnd_ = 1;
+	}
+	if (ssthresh_ < 2)
+		ssthresh_ = 2;
+	if (how & (CLOSE_CWND_HALF|CLOSE_CWND_RESTART|CLOSE_CWND_INIT|CLOSE_CWND_ONE))
+		cong_action_ = TRUE;
+
+	fcnt_ = count_ = 0;
+	if (first_decrease_ == 1)
+		first_decrease_ = 0;
+}
+
+/////
+// newack()
+/*
+ * Process a packet that acks previously unacknowleged data.
+ */
+
+
+void WestwoodNRTcpAgent::newack(Packet* pkt)
+{
+	hdr_tcp *tcph = hdr_tcp::access(pkt);
+	myseqno_ = tcph->seqno_;
+	//call parent newack
+	NewRenoTcpAgent::newack(pkt);
+}
+
+///// 
+// delay_bind_dispatch()
+//Westwood binds
+int
+WestwoodNRTcpAgent::delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer)
+{
+
+	if (delay_bind(varName, localName, "lastackno_", &lastackno_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "lastackrx_", &lastackrx_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "fr_alpha_", &fr_alpha_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "filter_type_", &filter_type_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "tau_", &tau_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "mss_", &mss_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "current_bwe_", &current_bwe_, tracer)) return TCL_OK;
+       	if (delay_bind(varName, localName, "last_bwe_sample_", &last_bwe_sample_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "unaccounted_", &unaccounted_, tracer)) return TCL_OK;
+        if (delay_bind(varName, localName, "fr_a_", &fr_a_, tracer)) return TCL_OK;
+        if (delay_bind(varName, localName, "min_rtt_estimate", &min_rtt_estimate, tracer)) return TCL_OK;
+  	if (delay_bind(varName, localName, "myseqno_", &myseqno_, tracer)) return TCL_OK;
+	
+	// these where originally in NewRenoTcpAgent()
+	if (delay_bind(varName, localName, "newreno_changes_", &newreno_changes_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "newreno_changes1_", &newreno_changes1_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "exit_recovery_fix_", &exit_recovery_fix_, tracer)) return TCL_OK;
+	if (delay_bind(varName, localName, "partial_window_deflation_", &partial_window_deflation_, tracer)) return TCL_OK;
+
+        return NewRenoTcpAgent::delay_bind_dispatch(varName, localName, tracer);
+}
+
+/* tickoff is the time since the clock last ticked when
+ *  the packet we are using to compute the RTT was sent
+ */
+
+/* t_rtt_ is the number of ticks that have occurred so far,
+ * starting from the tick BEFORE the packet was sent
+ */
+
+
diff -rupN ns-2.29/westwood/tcp-westwood-nr.h ns-2.29-click-scheduler/westwood/tcp-westwood-nr.h
--- ns-2.29/westwood/tcp-westwood-nr.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/westwood/tcp-westwood-nr.h	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,97 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1991-2001 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /mvalla/tcp-w-nr.h,v 1.0 2001/09/17 15:14:54 mvalla Exp mvalla $ (LBL)
+ */
+
+#ifndef tcp_w_nr_h
+#define tcp_w_nr_h
+
+#include "tcp.h"
+
+/* these are bits for how to change the cwnd and ssthresh values */
+/* used by TCP-W						 */
+#define CLOSE_FASTER	0x00000400
+
+/* TCP Westwood New Reno */
+
+class WestwoodNRTcpAgent : public virtual NewRenoTcpAgent {
+public:
+	WestwoodNRTcpAgent();
+	virtual void recv(Packet *pkt, Handler*);
+	virtual void dupack_action();
+	virtual void timeout (int tno);
+	
+	/* these where originally in class TcpAgent (file: tcp.h) */
+	virtual void slowdown(int how);
+	virtual void newack(Packet* pkt);
+	
+	virtual int  delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer);
+
+protected:
+	double lastackno_;  /* Last ACK number */
+	double lastackrx_;  /* Time last ACK was received */ 
+	double fr_alpha_;   /* exponential averaging coefficient */
+	int filter_type_;   /* exponential filter type */
+	double tau_;        /* time constant used in filter 3 */
+	double west_type_;
+	double qest_;
+	double total_time_;
+	double total_size_;
+	double fr_amin_;
+	double fr_amax_;
+	double fr_prev_;
+	int interp_type_;
+//used to overcome the effect of congestion on the ACK path
+	double last_ts_;
+	double last_echoed_ts_;
+	double current_ts_;
+	double current_echoed_ts_;
+	int last_seq_;
+	double last_cwnd_;
+	int openadd_;
+
+	/* these where originally in class TcpAgent (file: tcp.h) */
+ 	int mss_;       	/* Maximum Segment Size - MGM+CC 31/08/2000 */
+	double current_bwe_;    /* Current Bandwidth estimation */
+        double last_bwe_sample_;/* Last sample used to compute BWE */
+        int unaccounted_;       /* unaccounted ACKs already received */
+        double fr_a_;           /* bandwidth reduction factor */
+        double min_rtt_estimate;/* smaller recorded RTT estimate */
+        TracedInt myseqno_;     /* my own exportable copy of seqno */
+        
+        virtual void bwe_computation(Packet *pkt);
+	
+};
+
+#endif /* tcp_w_nr_h */
diff -rupN ns-2.29/wpan/p802_15_4mac.cc ns-2.29-click-scheduler/wpan/p802_15_4mac.cc
--- ns-2.29/wpan/p802_15_4mac.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/wpan/p802_15_4mac.cc	2007-03-08 15:12:37.000000000 +0100
@@ -4859,7 +4859,7 @@ void Mac802_15_4::taskSuccess(char task,
 			{
 				ch->size() -= macHeaderLen(wph->MHR_FrmCtrl);
 				ch->xmit_reason_ = 1;
-				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_);
+				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_, -1);
 			}
 			if (callback_)	
 			{
@@ -4918,7 +4918,7 @@ void Mac802_15_4::taskFailed(char task,M
 				wph->setSN = true;		
 				ch->size() -= macHeaderLen(wph->MHR_FrmCtrl);
 				ch->xmit_reason_ = 0;
-				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_);
+				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_, -1);
 			}
 			if (callback_			
 			&& (!dataWaitT->busy()))	
