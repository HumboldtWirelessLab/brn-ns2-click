diff -rupN ns-2.29/aodv/aodv.cc ns-2.29-click-scheduler/aodv/aodv.cc
--- ns-2.29/aodv/aodv.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/aodv/aodv.cc	2007-03-08 15:12:37.000000000 +0100
@@ -286,7 +286,7 @@ double total_latency = 0.0;
 */
 
 static void
-aodv_rt_failed_callback(Packet *p, void *arg) {
+aodv_rt_failed_callback(Packet *p, void *arg, int32_t retries) {
   ((AODV*) arg)->rt_ll_failed(p);
 }
 
diff -rupN ns-2.29/classifier/classifier-click.cc ns-2.29-click-scheduler/classifier/classifier-click.cc
--- ns-2.29/classifier/classifier-click.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/classifier/classifier-click.cc	2007-03-08 15:12:37.000000000 +0100
@@ -102,6 +102,15 @@ ClickClassifier::command(int argc, const
       }
       return TCL_OK;
     }
+    if (strcmp(argv[1], "halt") == 0) {
+      // runclick
+      if (clickinst_) {
+        simclick_simstate simstate;
+        simstate.curtime = GetSimTime();
+        simclick_click_kill(clickinst_,&simstate);
+      }
+      return TCL_OK;
+    }
   }
   else if (3 == argc) {
     if(strcmp(argv[1], "loadclick") == 0) {
@@ -212,6 +221,9 @@ ClickClassifier::~ClickClassifier() {
 
 int
 ClickClassifier::route(Packet* p) {
+
+  //fprintf(stderr,"ClickClassifier::route!!!\n");
+
   int result = 0;
   if (clickinst_) {
     unsigned char* data = NULL;
@@ -226,6 +238,11 @@ ClickClassifier::route(Packet* p) {
     int nssubtype = rhdr->subtype;
     int clicktype = GetClickPacketType(nssubtype);
     simpinfo.simtype = rhdr->ns_type;
+
+    // number of retries
+    simpinfo.retries = 0;
+    simpinfo.rx_power = p->txinfo_.RxPr;
+
     unsigned char* pdat = p->accessdata();
     data = new unsigned char[len];
     memcpy(data,pdat,len);
@@ -508,14 +525,14 @@ ClickClassifier::GetClickPacketType(int 
 
 
 void
-ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg) {
+ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg, int32_t retries) {
   // Hit the callback and then free the packet
-  ((ClickClassifier*)arg)->LinkLayerFailed(p);
+  ((ClickClassifier*)arg)->LinkLayerFailed(p, retries);
   Packet::free(p);
 }
 
 void
-ClickClassifier::LinkLayerFailed(Packet* p) {
+ClickClassifier::LinkLayerFailed(Packet* p, int32_t retries) {
   //fprintf(stderr,"XXX Lost a packet!!!\n");
   if (clickinst_) {
     unsigned char* data = NULL;
@@ -526,6 +543,10 @@ ClickClassifier::LinkLayerFailed(Packet*
     hdr_ip* iphdr = hdr_ip::access(p);
     simpinfo.id = chdr->uid();
     simpinfo.fid = iphdr->flowid();
+
+    // number of retries
+    simpinfo.retries = retries;
+
     hdr_raw* rhdr = hdr_raw::access(p);
     int nssubtype = rhdr->subtype;
     int clicktype = GetClickPacketType(nssubtype);
@@ -536,7 +557,7 @@ ClickClassifier::LinkLayerFailed(Packet*
     simstate.curtime = GetSimTime();
     //fprintf(stderr,"Sending packet up to click...\n");
     simclick_click_send(clickinst_,&simstate,ifid,clicktype,data,len,&simpinfo);
-    delete data;
+    delete[] data;
     data = 0;
   }
   else {
@@ -553,8 +574,6 @@ ClickClassifier::MakeRawPacket(int type,
    */
   hdr_raw* rhdr = hdr_raw::access(pkt);
   rhdr->subtype = GetNSSubtype(type);
-  unsigned char* pdat = pkt->accessdata();
-  memcpy(pdat,data,len);
 
   /*
    * Set some of the packet header stuff ns-2 wants
@@ -573,12 +592,6 @@ ClickClassifier::MakeRawPacket(int type,
   chdr->xmit_failure_ = LinkLayerFailedCallback;
   chdr->xmit_failure_data_ = (void*)this;
 
-  hdr_ip* iphdr = hdr_ip::access(pkt);
-  iphdr->flowid() = 0;
-  if (pinfo->fid >= 0) {
-    iphdr->flowid() = pinfo->fid;
-  }
-
   /*
    * A packet coming in from click on the kernel tap device is
    * considered to be going up into the node, on any other device
@@ -599,6 +612,12 @@ ClickClassifier::MakeRawPacket(int type,
     }
   }
 
+  // Got an IP packet? Must have come from click, and therefore
+  // the next hop is us.
+  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
+    chdr->next_hop() = nodeaddr_;
+  }
+
   // If we've got ethernet encapsulation, translate mac address
   // to ns address. Otherwise we're SOL.
   struct hdr_mac* mhdr = HDR_MAC(pkt);
@@ -621,11 +640,40 @@ ClickClassifier::MakeRawPacket(int type,
     mhdr->macDA_ = MAC_BROADCAST;
   }
 
-  // Got an IP packet? Must have come from click, and therefore
-  // the next hop is us.
-  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
-    chdr->next_hop() = nodeaddr_;
+  // Prepare ip header
+  hdr_ip* iphdr = hdr_ip::access(pkt);
+  iphdr->flowid() = 0;
+  if (pinfo->fid >= 0) {
+    iphdr->flowid() = pinfo->fid;
   }
+/*
+  click_ip* cip =  (click_ip*)data;
+  iphdr->saddr() = cip->ip_src;
+  iphdr->daddr() = cip->ip_dst;
+  iphdr->ttl()   = cip->ip_ttl;
+  
+  data += sizeof(click_ip);
+  len  -= sizeof(click_ip);
+
+  if (6 == cip->ip_p) { // TCP
+    hdr_tcp *tcph = hdr_tcp::access(pkt); // TCP header
+    hdr_flags *fh = hdr_flags::access(pkt); // flags (CWR, CE, bits)
+    click_tcp* ctcp = (click_tcp*) data;
+
+    iphdr->sport() = ctcp->th_sport;
+    iphdr->dport() = ctcp->th_dport;
+    tcph->seqno() = ctcp->th_seq;
+    tcph->hlen()  = ctcp->
+    tcph->ackno() = ctcp->th_ack;
+    tcph->flags() = ctcp->th_flags;
+    
+    data += sizeof(click_ip);
+    len  -= sizeof(click_ip);
+  }
+  //else if (17 == cip->ip_p) { // UDP
+*/
+  unsigned char* pdat = pkt->accessdata();
+  memcpy(pdat,data,len);
 
   return pkt;
 }
diff -rupN ns-2.29/classifier/classifier-click.h ns-2.29-click-scheduler/classifier/classifier-click.h
--- ns-2.29/classifier/classifier-click.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/classifier/classifier-click.h	2007-03-08 15:12:37.000000000 +0100
@@ -139,8 +139,8 @@ class ClickClassifier : public ExtClassi
   int GetNodeAddr(); /// ToNSTrace
   int IFReady(int ifid);
   simclick_click GetClickinst() { return clickinst_; }
-  static void LinkLayerFailedCallback(Packet* p, void* arg);
-  void LinkLayerFailed(Packet* p);
+  static void LinkLayerFailedCallback(Packet* p, void* arg, int32_t retries);
+  void LinkLayerFailed(Packet* p, int32_t retries);
   void trace(char* fmt, ...); /// ToNSTrace
   int GetNextPktID(); /// ToNSTrace
  protected:
diff -rupN ns-2.29/common/agent.cc ns-2.29-click-scheduler/common/agent.cc
--- ns-2.29/common/agent.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/common/agent.cc	2007-03-08 15:12:37.000000000 +0100
@@ -474,15 +474,15 @@ Agent::toraw(Packet* p) {
 	struct hdr_ip* hip = HDR_IP(p);
 	struct hdr_cmn* hcmn = HDR_CMN(p);
 	struct hdr_raw* hraw = hdr_raw::access(p);
-	int packetlen = sizeof(click_ip) + hcmn->size_;
-	int paylen = hcmn->size_;
+	int packetlen = hcmn->size_;
+	int paylen = packetlen - sizeof(click_ip);
 	unsigned char* pdat = 0;
 
 	// build packet length
 	if (hcmn->ptype_ == PT_ACK || hcmn->ptype_ == PT_TCP)
-		packetlen += sizeof(click_tcp);
+		paylen -= sizeof(click_tcp);
 	else if (hcmn->ptype_ == PT_CBR)
-		packetlen += sizeof(click_udp);
+		paylen -= sizeof(click_udp);
 	else
 		return false;
 
@@ -534,7 +534,7 @@ Agent::toraw(Packet* p) {
 		tcp->th_flags = htcp->tcp_flags_;
 		if (hcmn->ptype_ == PT_ACK)
 			tcp->th_flags |= TH_ACK;
-		tcp->th_win = 0; /* XXX */
+		tcp->th_win = htons(htcp->window_);
 		tcp->th_urp = 0;
 		tcp->th_sum = 0;
 		uint16_t len = packetlen - sizeof(click_ip);
@@ -578,6 +578,7 @@ Agent::fromraw(Packet* p) {
 		htcp->tcp_flags_ = tcp->th_flags;
 		htcp->hlen_ = (ip->ip_hl << 2) + (tcp->th_off << 2);
 		hcmn->ptype_ = (tcp->th_flags & TH_ACK) ? PT_ACK : PT_TCP;
+    htcp->window_ = ntohl(tcp->th_win);
 		result = true;
 		break;
 	case IPPROTO_UDP:
@@ -585,6 +586,8 @@ Agent::fromraw(Packet* p) {
 		result = true;
 		break;
 	default:
+    hcmn->ptype_ = PT_NTYPE;
+    printf("ERROR: Agent::fromraw got packet with unknown type %d.", ip->ip_p);
 		result = false;
 		break;
 	}
diff -rupN ns-2.29/common/packet.h ns-2.29-click-scheduler/common/packet.h
--- ns-2.29/common/packet.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/common/packet.h	2007-03-08 15:12:37.000000000 +0100
@@ -270,7 +270,8 @@ public:
 		name_[PT_NTYPE]= "undefined";
 	}
 	const char* name(packet_t p) const { 
-		if ( p <= PT_NTYPE ) return name_[p];
+		if ( 0 <= p && p <= PT_NTYPE ) return name_[p];
+    printf("ERROR: p_info::name invalid packet type %d.", p);
 		return 0;
 	}
 	static bool data_packet(packet_t type) {
@@ -336,7 +337,7 @@ private:
 };
 
 //Monarch ext
-typedef void (*FailureCallback)(Packet *,void *);
+typedef void (*FailureCallback)(Packet *,void *, int32_t);
 
 class Packet : public Event {
 private:
@@ -620,6 +621,7 @@ inline Packet* Packet::copy() const
 	if (data_) 
 		p->data_ = data_->copy();
 	p->txinfo_.init(&txinfo_);
+  p->uid_ = this->uid_;
  
 	return (p);
 }
diff -rupN ns-2.29/diffusion/diffusion.cc ns-2.29-click-scheduler/diffusion/diffusion.cc
--- ns-2.29/diffusion/diffusion.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/diffusion.cc	2007-03-08 15:12:37.000000000 +0100
@@ -459,7 +459,7 @@ void DiffusionAgent::MACsend(Packet *pkt
 }
 
 
-void XmitFailedCallback(Packet *pkt, void *data)
+void XmitFailedCallback(Packet *pkt, void *data, int32_t retries)
 {
   DiffusionAgent *agent = (DiffusionAgent *)data;  // cast of trust
   agent->xmitFailed(pkt);
diff -rupN ns-2.29/diffusion/diffusion.h ns-2.29-click-scheduler/diffusion/diffusion.h
--- ns-2.29/diffusion/diffusion.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/diffusion.h	2008-08-28 16:32:23.000000000 +0200
@@ -137,8 +137,7 @@ class SendBufTimer : public TimerHandler
   DiffusionAgent *a_;
 };
 
-
-void XmitFailedCallback(Packet *pkt, void *data);
+void XmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 class ArpBufferTimer;
 class SendBufTimer;
 
@@ -207,7 +206,7 @@ class DiffusionAgent : public Agent {
 
   void trace(char *fmt,...);
 
-  friend void XmitFailedCallback(Packet *pkt, void *data);
+  friend void XmitFailedCallback(Packet *pkt, void *data, int32_t retries);
   friend class ArpBufferTimer;
   friend class SendBufTimer;
 };
diff -rupN ns-2.29/diffusion/omni_mcast.cc ns-2.29-click-scheduler/diffusion/omni_mcast.cc
--- ns-2.29/diffusion/omni_mcast.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/omni_mcast.cc	2007-03-08 15:12:37.000000000 +0100
@@ -419,7 +419,7 @@ void OmniMcastAgent::MACsend(Packet *pkt
 }
 
 
-void OmniMcastXmitFailedCallback(Packet *pkt, void *data)
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries)
 {
   OmniMcastAgent *agent = (OmniMcastAgent *)data;  // cast of trust
   agent->xmitFailed(pkt);
diff -rupN ns-2.29/diffusion/omni_mcast.h ns-2.29-click-scheduler/diffusion/omni_mcast.h
--- ns-2.29/diffusion/omni_mcast.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/diffusion/omni_mcast.h	2008-08-28 16:33:12.000000000 +0200
@@ -157,7 +157,7 @@ class OmniMcast_Entry {
 
 
 
-void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 
 class OmniMcastArpBufferTimer;
 class OmniMcastSendBufTimer;
@@ -222,7 +222,7 @@ class OmniMcastAgent : public Agent {
 
   void trace(char *fmt,...);
 
-  friend void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+  friend void OmniMcastXmitFailedCallback(Packet *pkt, void *data, int32_t retries);
 
   friend class OmniMcastArpBufferTimer;
   friend class OmniMcastSendBufTimer;
diff -rupN ns-2.29/dsdv/dsdv.cc ns-2.29-click-scheduler/dsdv/dsdv.cc
--- ns-2.29/dsdv/dsdv.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/dsdv/dsdv.cc	2007-03-08 15:12:37.000000000 +0100
@@ -413,7 +413,7 @@ DSDV_Agent::lost_link (Packet *p)
 }
 
 static void 
-mac_callback (Packet * p, void *arg)
+mac_callback (Packet * p, void *arg, int32_t retries)
 {
   ((DSDV_Agent *) arg)->lost_link (p);
 }
diff -rupN ns-2.29/dsr/dsragent.cc ns-2.29-click-scheduler/dsr/dsragent.cc
--- ns-2.29/dsr/dsragent.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/dsr/dsragent.cc	2007-03-08 15:12:37.000000000 +0100
@@ -2786,14 +2786,14 @@ DSRAgent::xmitFailed(Packet *pkt, const 
 }
 
 void
-XmitFailureCallback(Packet *pkt, void *data)
+XmitFailureCallback(Packet *pkt, void *data, int32_t retries)
 {
   DSRAgent *agent = (DSRAgent *)data; // cast of trust
   agent->xmitFailed(pkt);
 }
 
 void
-XmitFlowFailureCallback(Packet *pkt, void *data)
+XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries)
 {
   DSRAgent *agent = (DSRAgent *)data;
   agent->xmitFlowFailed(pkt);
diff -rupN ns-2.29/dsr/dsragent.h ns-2.29-click-scheduler/dsr/dsragent.h
--- ns-2.29/dsr/dsragent.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/dsr/dsragent.h	2008-08-28 16:36:13.000000000 +0200
@@ -110,8 +110,8 @@ protected:
 
 LIST_HEAD(DSRAgent_List, DSRAgent);
 
-void XmitFailureCallback(Packet *pkt, void *data);
-void XmitFlowFailureCallback(Packet *pkt, void *data);
+void XmitFailureCallback(Packet *pkt, void *data, int32_t retries);
+void XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries);
 int FilterFailure(Packet *p, void *data);
 class SendBufferTimer;
 
@@ -270,8 +270,8 @@ private:
   void testinit();
   void trace(char* fmt, ...);
 
-  friend void XmitFailureCallback(Packet *pkt, void *data);
-  friend void XmitFlowFailureCallback(Packet *pkt, void *data);
+  friend void XmitFailureCallback(Packet *pkt, void *data, int32_t retries);
+  friend void XmitFlowFailureCallback(Packet *pkt, void *data, int32_t retries);
   friend int FilterFailure(Packet *p, void *data);
   friend class SendBufferTimer;
 
diff -rupN ns-2.29/imep/imep.cc ns-2.29-click-scheduler/imep/imep.cc
--- ns-2.29/imep/imep.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/imep/imep.cc	2007-03-08 15:12:37.000000000 +0100
@@ -76,7 +76,7 @@ public:
 
 // MAC layer callback
 static void
-imep_failed_callback(Packet *p, void *arg)
+imep_failed_callback(Packet *p, void *arg, int32_t retries)
 {
 	if(imep_use_mac_callback)
 		((imepAgent*) arg)->imepPacketUndeliverable(p);
diff -rupN ns-2.29/mac/arp.cc ns-2.29-click-scheduler/mac/arp.cc
--- ns-2.29/mac/arp.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/arp.cc	2007-03-08 15:12:37.000000000 +0100
@@ -161,7 +161,7 @@ ARPTable::arpresolve(nsaddr_t dst, Packe
 
                         if (ch->xmit_failure_) {
                                 ch->xmit_reason_ = 0;
-                                ch->xmit_failure_(t, ch->xmit_failure_data_);
+                                ch->xmit_failure_(t, ch->xmit_failure_data_, -1);
                         }
                         else {
                                 drop(t, DROP_IFQ_ARP_FULL);
@@ -172,7 +172,7 @@ ARPTable::arpresolve(nsaddr_t dst, Packe
 
 		if (ch->xmit_failure_) {
                         ch->xmit_reason_ = 0;
-                        ch->xmit_failure_(p, ch->xmit_failure_data_);
+                        ch->xmit_failure_(p, ch->xmit_failure_data_, -1);
                 }
                 else {
                         drop(p, DROP_IFQ_ARP_FULL);
diff -rupN ns-2.29/mac/channel.cc ns-2.29-click-scheduler/mac/channel.cc
--- ns-2.29/mac/channel.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/mac/channel.cc	2007-03-08 15:12:37.000000000 +0100
@@ -387,7 +387,10 @@ WirelessChannel::sendUp(Packet* p, Phy *
 			 
 			 rifp = (rnode->ifhead()).lh_first;
 			 for(; rifp; rifp = rifp->nextnode()){
-				 s.schedule(rifp, newp, propdelay);
+        if (rifp->channel() == this){
+         s.schedule(rifp, newp, propdelay); 
+         break;
+        }
 			 }
 		 }
 		 delete [] affectedNodes;
diff -rupN ns-2.29/mac/mac-802_11.cc ns-2.29-click-scheduler/mac/mac-802_11.cc
--- ns-2.29/mac/mac-802_11.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-802_11.cc	2007-03-08 15:12:37.000000000 +0100
@@ -81,7 +81,21 @@ inline void
 Mac802_11::checkBackoffTimer()
 {
 	if(is_idle() && mhBackoff_.paused())
-		mhBackoff_.resume(phymib_.getDIFS());
+		// BUGFIX UKA: EIFS
+		// When the channel becomes free again the station will have
+        // to back off with DIFS or EIFS period depending on the
+        // last received packet
+
+        // old implementation
+		// mhBackoff_.resume(phymib_.getDIFS());
+         
+        // new implementation
+		if (last_packet_correct_ == true)
+			mhBackoff_.resume(phymib_.getDIFS());
+        else
+            mhBackoff_.resume(phymib_.getEIFS());
+		// BUGFIX UKA END: EIFS
+
 	if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.paused())
 		mhBackoff_.pause();
 }
@@ -106,7 +120,22 @@ Mac802_11::transmit(Packet *p, double ti
 		//assert(dh->dh_fc.fc_subtype == MAC_Subtype_ACK);
 		assert(pktRx_);
 		struct hdr_cmn *ch = HDR_CMN(pktRx_);
-		ch->error() = 1;        /* force packet discard */
+
+	    // BUGFIX UKA: TxRxError
+        // If a station transmits it cannot sense and thus not receive
+        // packets at the same time physically. In the original simulator 
+        // however such a packet is "received", marked errornous, discarded
+        // and an EIFS period follows.
+        // This however should not happen, because the packet is not sensed.
+        // Therefore the packet that is received is marked special and handled
+        // correctly after complete "reception" (handle it as "never sensed")
+		
+        // old implementation
+        //ch->error() = 1;        /* force packet discard */
+        
+        // new implementation
+    ch->error() = TX_RX_ERROR;
+    // BUGFIX UKA END: TxRxError
 	}
 
 	/*
@@ -167,6 +196,13 @@ PHY_MIB::PHY_MIB(Mac802_11 *parent)
 	parent->bind("PreambleLength_", &PreambleLength);
 	parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);
 	parent->bind_bw("PLCPDataRate_", &PLCPDataRate);
+
+    // BUGFIX UKA: capture
+    // bind variable 
+    // Set newchipset_ to false for classical chipset behavior
+    // Set to true for improved capture support.
+    parent->bind_bool("newchipset_", &newchipset);
+    // BUGFIX UKA END: capture
 }
 
 MAC_MIB::MAC_MIB(Mac802_11 *parent)
@@ -205,6 +241,16 @@ Mac802_11::Mac802_11() : 
 	cache_ = 0;
 	cache_node_count_ = 0;
 	
+    // BUGFIX UKA: capture
+    // saves the point of time of the start of the last packet reception
+    time_start_pktRx_= 0.0;
+    // BUGFIX UKA END: capture
+
+    // BUGFIX UKA: EIFS
+    // On initialization the last received packet is assumed as correct.
+    last_packet_correct_ = true;
+    // BUGFIX UKA END: EIFS
+
 	// chk if basic/data rates are set
 	// otherwise use bandwidth_ as default;
 	
@@ -406,6 +452,50 @@ Mac802_11::is_idle()
 	return 1;
 }
 
+// BUGFIX UKA: EIFS
+// Two new functions for setting and resetting EIFS state
+
+// Set_eifs: This method is called after an errornous packet
+// reception, It sets last_packet_correct to false and
+// starts the defer timer if backoff is not already running 
+// (in that case, the backoff timer cares about EIFS on
+// resume (see checkbackofftimer()).
+
+inline void
+Mac802_11::set_eifs() {
+last_packet_correct_ = false;
+  /*
+   *  Stop deferring - will be reset in tx_resume().
+   */
+  if(mhDefer_.busy()) mhDefer_.stop();
+
+if (mhBackoff_.busy() == false)  {
+    mhDefer_.start(phymib_.getEIFS());
+}
+
+}
+
+// reset_eifs: If the station starts receiving a packet, reset_eifs is
+// called. It checks if the station is in the EIFS period and if this is
+// done by defer timer. If this is the case the defer timer is stopped. If
+// there are packets to send then the station will initialize a backoff
+// period (if not already running), that is directly paused until the 
+// medium is idle again.
+
+inline void
+Mac802_11::reset_eifs()
+{
+if (last_packet_correct_ == false && mhDefer_.busy() == true) {
+    mhDefer_.stop();
+    if (mhBackoff_.busy() == false && (pktRTS_ || pktTx_)) {
+        mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+
+    }
+}
+}
+
+// BUGFIX UKA END: EIFS
+
 void
 Mac802_11::discard(Packet *p, const char* why)
 {
@@ -471,12 +561,51 @@ Mac802_11::discard(Packet *p, const char
 void
 Mac802_11::capture(Packet *p)
 {
-	/*
-	 * Update the NAV so that this does not screw
-	 * up carrier sense.
-	 */	
-	set_nav(usec(phymib_.getEIFS() + txtime(p)));
-	Packet::free(p);
+// BUGFIX UKA: capture, EIFS
+// Changes concerning capture effect:
+// - Packets that are discarded because of the capture effect are 
+//   mentioned in  the trace
+// - A new version of the chipset implementation that handles an 
+//   "extended capture effect" is implemented
+// Changes concerning EIFS handling:
+// - NAV is not used for EIFS handling anymore; replace by mechnism
+//   using last_packet_correct_ variable and defer/backoff timers
+
+// old implementation
+
+/*
+ * Update the NAV so that this does not screw
+ * up carrier sense.
+ */
+// set_nav(usec(phymib_.getEIFS() + txtime(p)));
+// Packet::free(p);
+
+// new implementation
+
+last_packet_correct_ = false;
+
+if (phymib_.get_newchipset() == false) {
+    // handle the classical capture effect (new chipset feature is not used)
+    discard(p, DROP_MAC_CAPTURE);
+} else {
+// handle capture effect if (new chipset feature used)
+
+    if (pktRx_->txinfo_.RxPr > p->txinfo_.RxPr){
+        // RxPr first packet > RxPr second packet 
+        // (power difference a priori big enough, otherwise capture is not called)
+        // => continue receive packet 1, discard packet 2
+        discard(p,DROP_MAC_CAPTURE);
+    } else {
+        // RxPr first packet < RxPr second packet 
+        // (power difference a priori big enough, otherwise capture is not called)
+        // => stop receive packet 1 and discard, receive packet 2 from now on
+        mhRecv_.stop();                     // receive timer for packet 1 stopped
+        mhRecv_.start(txtime(p));           // start receive timer for packet 2
+        discard(pktRx_, DROP_MAC_CAPTURE);  // discard packet 1
+        pktRx_ = p;                         // make packet 2 the one that is received now
+    }
+}
+// BUGFIX UKA END: capture, EIFS
 }
 
 void
@@ -495,6 +624,13 @@ Mac802_11::collision(Packet *p)
 		 *  "last" the longest.  Make this packet,
 		 *  pktRx_ and reset the Recv Timer if necessary.
 		 */
+
+    // BUGFIX UKA: EIFS
+    // A collision implies reception of an errornous packet
+    // set the last_packet_correct_ variable to false
+     last_packet_correct_ = false;
+    // BUGFIX UKA END: EIFS
+
 		if(txtime(p) > mhRecv_.expire()) {
 			mhRecv_.stop();
 			discard(pktRx_, DROP_MAC_COLLISION);
@@ -513,6 +649,9 @@ Mac802_11::collision(Packet *p)
 void
 Mac802_11::tx_resume()
 {
+  if (mhDefer_.busy())
+    dump("mac-802.11");
+    
 	double rTime;
 	assert(mhSend_.busy() == 0);
 	assert(mhDefer_.busy() == 0);
@@ -524,8 +663,20 @@ Mac802_11::tx_resume()
 		mhDefer_.start(phymib_.getSIFS());
 	} else if(pktRTS_) {
 		if (mhBackoff_.busy() == 0) {
-			rTime = (Random::random() % cw_) * phymib_.getSlotTime();
-			mhDefer_.start( phymib_.getDIFS() + rTime);
+        // BUGFIX UKA: transmission 
+        //
+        // Do backoff period using the (interruptable) backoff timer, not
+        // the (non-interruptable) defer timer
+        
+        // old implementation
+        
+        //rTime = (Random::random() % cw_) * phymib_.getSlotTime();
+        //mhDefer_.start( phymib_.getDIFS() + rTime);
+        
+        // new implementation
+        
+        mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        //BUGFIX UKA END: transmission 
 		}
 	} else if(pktTx_) {
 		if (mhBackoff_.busy() == 0) {
@@ -534,9 +685,21 @@ Mac802_11::tx_resume()
 			
 			if ((u_int32_t) ch->size() < macmib_.getRTSThreshold()
 			    || (u_int32_t) ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
-				rTime = (Random::random() % cw_)
-					* phymib_.getSlotTime();
-				mhDefer_.start(phymib_.getDIFS() + rTime);
+            // BUGFIX UKA: transmission 
+            //
+            // Do backoff period using the (interruptable) backoff timer,
+            // not the (non-interruptable) defer timer
+
+            // old implementation
+        
+            // rTime = (Random::random() % cw_)
+            //	* phymib_.getSlotTime();
+            // mhDefer_.start(phymib_.getDIFS() + rTime);
+            
+            // new implementation
+            
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: transmission 
                         } else {
 				mhDefer_.start(phymib_.getSIFS());
                         }
@@ -579,7 +742,21 @@ Mac802_11::backoffHandler()
 void
 Mac802_11::deferHandler()
 {
-	assert(pktCTRL_ || pktRTS_ || pktTx_);
+// BUGFIX UKA: EIFS
+
+// Defer timer is also used for EIFS handling now. This method is called at
+// the end of a complete EIFS. The assertion needs to be extended and the 
+// last_packet_correct_ variable has to be reset.
+
+// old implementation
+
+// assert(pktCTRL_ || pktRTS_ || pktTx_);
+
+// new implementation
+
+assert(pktCTRL_ || pktRTS_ || pktTx_ || last_packet_correct_ == false);
+last_packet_correct_ = true;
+// BUGFIX UKA END: EIFS
 
 	if(check_pktCTRL() == 0)
 		return;
@@ -593,8 +770,19 @@ Mac802_11::deferHandler()
 void
 Mac802_11::navHandler()
 {
-	if(is_idle() && mhBackoff_.paused())
-		mhBackoff_.resume(phymib_.getDIFS());
+// BUGFIX UKA: NAV 
+// If NAV finishes, paused backoff timers have to be resumed.
+// Use the appropriate method instead of an individual solution here.
+
+// old implementation
+
+// if(is_idle() && mhBackoff_.paused())
+// mhBackoff_.resume(phymib_.getDIFS());
+
+// new implementation
+
+checkBackoffTimer();
+// BUGFIX UKA END: NAV
 }
 
 void
@@ -738,8 +926,26 @@ Mac802_11::check_pktRTS()
  	switch(mh->dh_fc.fc_subtype) {
 	case MAC_Subtype_RTS:
 		if(! is_idle()) {
-			inc_cw();
-			mhBackoff_.start(cw_, is_idle());
+			// BUGFIX UKA: transmission 
+            // The contention window should only be increased before retransmit
+            // (see Standard spec. section 9.2.4)
+            
+            // old implementation
+            
+            // inc_cw();
+            // BUGFIX UKA END: transmission
+            
+            // BUGFIX UKA: EIFS
+            // changed method definition for backoff start causes changed call
+            
+            // old implementation
+             
+			// mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+             
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
 			return 0;
 		}
 		setTxState(MAC_RTS);
@@ -776,8 +982,27 @@ Mac802_11::check_pktTx()
 	case MAC_Subtype_Data:
 		if(! is_idle()) {
 			sendRTS(ETHER_ADDR(mh->dh_ra));
-			inc_cw();
-			mhBackoff_.start(cw_, is_idle());
+			// BUGFIX UKA: transmission 
+            // The contention window should only be increased before retransmit
+            // (see Standard spec. section 9.2.4)
+            
+            // old implementation
+            
+            // inc_cw();
+            // BUGFIX UKA END: transmission 
+            
+            // BUGFIX UKA: EIFS
+            // changed method definition for backoff start causes changed call
+            
+            // old implementation
+             
+			// mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+             
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
+			
 			return 0;
 		}
 		setTxState(MAC_SEND);
@@ -999,6 +1224,51 @@ Mac802_11::sendDATA(Packet *p)
 /* ======================================================================
    Retransmission Routines
    ====================================================================== */
+
+// BUGFIX UKA: EIFS
+//
+// The new implementation of EIFS causes a more complicated retransmission 
+// handling. Depending on the expiration time of EIFS backoff timers have to 
+// be initialized with different waiting times. Since this functionality
+// is needed at severeal places in the RetransmitRTS and RetransmitDATA 
+// methods, it is expoerted to an own method, StartRetransmitBackoff.
+
+void
+Mac802_11::StartRetransmitBackoff()
+{
+    // Set tx state to idle first so that the correct waiting time is used.
+    // This is VERY dirty, but if the medium is not idle here, we would never start
+    // e.g. with expire time of defer handler, but it would always be paused directly
+    // and on resume, DIFS or EIFS is chosen.
+    // 
+    // This call does not change anything, because after leaving this method, we
+    // leave RestransmitRTS/DATA, and then, this call comes in send_timer in every
+    // case, where tx state would be set to idle.
+    setTxState(MAC_IDLE);
+
+    if (last_packet_correct_ == false && mhDefer_.busy()) {
+    	// defer is running because of EIFS => stop defering, start backoff
+        if (mhDefer_.expire() < phymib_.getDIFS()) {
+            // time until defer expires is shorter than DIFS => start BO with DIFS
+            mhDefer_.stop();
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        } else {
+            // time until defer expires is greater than DIFS => wait rest of defer
+	        // (complete EIFS) and do backoff slots then
+            mhBackoff_.start(cw_, is_idle(), mhDefer_.expire());
+            mhDefer_.stop();
+        }
+     } else {
+        // no defer running; just start backoff
+        if (mhBackoff_.busy() == false) {
+            mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+        }
+    }
+}
+
+// BUGFIX UKA END:EIFS
+
+
 void
 Mac802_11::RetransmitRTS()
 {
@@ -1024,7 +1294,8 @@ Mac802_11::RetransmitRTS()
 			ch->size() -= phymib_.getHdrLen11();
                         ch->xmit_reason_ = XMIT_REASON_RTS;
                         ch->xmit_failure_(pktTx_->copy(),
-                                          ch->xmit_failure_data_);
+                                          ch->xmit_failure_data_,
+                                          ssrc_);
                 }
 		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
 		pktTx_ = 0;
@@ -1036,8 +1307,27 @@ Mac802_11::RetransmitRTS()
 		rf->rf_fc.fc_retry = 1;
 
 		inc_cw();
-		mhBackoff_.start(cw_, is_idle());
-	}
+		// BUGFIX UKA: EIFS
+		// call StartRetransmitBackoff instead of directly starting backoff
+		// This is now done at the end of this method.
+
+        // old implementation
+         
+		// mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA END: EIFS
+	}
+    
+	// BUGFIX UKA: transmission, EIFS
+	// transmission: backoff is started here, because it has to be done in every
+	// case and not only in case of not reaching the limit.
+	// EIFS: backoff is not started directly but uses StartRetransmitBackoff 
+    // method.
+
+    // new implementation
+
+    StartRetransmitBackoff();
+	// BUGFIX UKA END: transmission, EIFS
+
 }
 
 void
@@ -1046,7 +1336,15 @@ Mac802_11::RetransmitDATA()
 	struct hdr_cmn *ch;
 	struct hdr_mac802_11 *mh;
 	u_int32_t *rcount, thresh;
-	assert(mhBackoff_.busy() == 0);
+	
+    // BUGFIX UKA: EIFS
+    // This assertion is not always valid, the BO timer might already be 
+    // running after an EIFS period
+    
+    // old implementation
+    
+    // assert(mhBackoff_.busy() == 0);
+    // BUGFIX UKA END: EIFS
 
 	assert(pktTx_);
 	assert(pktRTS_ == 0);
@@ -1062,11 +1360,28 @@ Mac802_11::RetransmitDATA()
 		Packet::free(pktTx_); 
 		pktTx_ = 0;
 
-		/*
+        // BUGFIX UKA: transmission 
+        // After sending a packet with a group address, both the short and 
+        // long retry counter should be reset (see Standard 9.2.4)
+        ssrc_ = 0;
+        slrc_ = 0;
+        // BUGFIX UKA END: transmission
+
+        /*
 		 * Backoff at end of TX.
 		 */
 		rst_cw();
-		mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA: EIFS
+		// Call StartRetransmitBackoff instead of directly starting backoff
+
+        // old implementation
+
+		// mhBackoff_.start(cw_, is_idle());
+    
+        // new implementation
+
+		StartRetransmitBackoff();
+		// BUGFIX UKA END: EIFS
 
 		return;
 	}
@@ -1094,7 +1409,8 @@ Mac802_11::RetransmitDATA()
                         ch->size() -= phymib_.getHdrLen11();
 			ch->xmit_reason_ = XMIT_REASON_ACK;
                         ch->xmit_failure_(pktTx_->copy(),
-                                          ch->xmit_failure_data_);
+                                          ch->xmit_failure_data_,
+                                          -1);
                 }
 
 		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
@@ -1107,11 +1423,28 @@ Mac802_11::RetransmitDATA()
 		dh = HDR_MAC802_11(pktTx_);
 		dh->dh_fc.fc_retry = 1;
 
-
 		sendRTS(ETHER_ADDR(mh->dh_ra));
 		inc_cw();
-		mhBackoff_.start(cw_, is_idle());
-	}
+		// BUGFIX UKA: EIFS
+		// Call StartRetransmitBackoff at the ned of the method instead of 
+        // directly starting backoff
+
+        // old implementation
+
+		// mhBackoff_.start(cw_, is_idle());
+		// BUGFIX UKA END: EIFS
+	}
+    
+	// BUGFIX UKA: transmission, EIFS
+	// transmission: backoff is started here, because it has to be done in every
+	// case and not only in case of not reaching the limit.
+	// EIFS: backoff is not started directly but uses StartRetransmitBackoff 
+    // method.
+
+    // new implementation
+
+    StartRetransmitBackoff();
+	// BUGFIX UKA END: transmission, EIFS
 }
 
 /* ======================================================================
@@ -1149,16 +1482,57 @@ Mac802_11::send(Packet *p, Handler *h)
 				 * If we are already deferring, there is no
 				 * need to reset the Defer timer.
 				 */
-				rTime = (Random::random() % cw_)
-					* (phymib_.getSlotTime());
-				mhDefer_.start(phymib_.getDIFS() + rTime);
+				// BUGFIX UKA: transmission 
+				// The station must defer only for DIFS if the medium is free
+                // and the is no backoff or defer runnning
+                
+                // old implementation
+                 
+				// rTime = (Random::random() % cw_)
+				// 	* (phymib_.getSlotTime());
+				// mhDefer_.start(phymib_.getDIFS() + rTime);
+                
+                // new implementation
+                
+				mhDefer_.start(phymib_.getDIFS() );
+				// BUGFIX UKA END: transmission
+
+			}
+			// BUGFIX UKA: EIFS
+			// support of EIFS causes new situations at packet sending as well
+            // If the last packet was not correct and defer is running and the
+            // medium is free, defer runs in an EIFS period. If now the time
+            // until expiration is smaller than DIFS, it is necessary to wait
+            // at least for an additional period of DIFS before sending.
+            
+            // new implementation
+			
+            else {
+				if (last_packet_correct_ == false && mhDefer_.expire() < phymib_.getDIFS()) {
+					// Defer runs because of EIFS and expiration
+					// time is shorter than DIFS
+					// => defer for DIFS again
+					mhDefer_.stop();
+					mhDefer_.start(phymib_.getDIFS());
+				}
 			}
+			// BUGFIX UKA END: EIFS
 		} else {
 			/*
 			 * If the medium is NOT IDLE, then we start
 			 * the backoff timer.
 			 */
-			mhBackoff_.start(cw_, is_idle());
+            // BUGFIX UKA: EIFS
+            // method call for backoff start changed
+            
+            // old implementation
+             
+            // mhBackoff_.start(cw_, is_idle());
+            
+            // new implementation
+            
+			mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+            // BUGFIX UKA END: EIFS
 		}
 	}
 }
@@ -1194,9 +1568,35 @@ Mac802_11::recv(Packet *p, Handler *h)
 	 *  proceed.  Just set the error flag in the common header
 	 *  to that the packet gets thrown away.
 	 */
-	if(tx_active_ && hdr->error() == 0) {
-		hdr->error() = 1;
-	}
+	// BUGFIX UKA: TxRxError
+    // packets at the same time physically. In the original simulator 
+    // however such a packet is "received", marked errornous, discarded
+    // and an EIFS period follows.
+    // This however should not happen, because the packet is not sensed.
+    // Therefore the packet that is received is marked special and handled
+    // correctly after complete "reception" (handle it as "never sensed")
+    
+    // old implementation
+
+	//if(tx_active_ && hdr->error() == 0) {
+	//	hdr->error() = 1;
+	// }
+    
+    // new implementation
+    
+	if (tx_active_) {
+	 	hdr->error() = TX_RX_ERROR;
+	}
+	// BUGFIX UKA END: TxRxError
+
+	// BUGFIX UKA: EIFS
+    // on receiving a packet, a running EIFS period is stopped
+
+    // new implementation
+    
+	reset_eifs();
+	// BUGFIX UKA END: EIFS
+
 
 	if(rx_state_ == MAC_IDLE) {
 		setRxState(MAC_RECV);
@@ -1206,17 +1606,70 @@ Mac802_11::recv(Packet *p, Handler *h)
 		 * txtime seconds.
 		 */
 		mhRecv_.start(txtime(p));
-	} else {
+        // BUGFIX UKA: capture
+        // The starting time of packet reception has to be stored to make sure
+        // the capture mechanism is simulated correctly. The new capture
+        // effect does not work if the starting time of the second packet 
+        // reception is in the interval between 4 and 10ms after the start of 
+        // the first reception.
+
+        // new implementation
+        
+		time_start_pktRx_ = Scheduler::instance().clock();
+		// BUGFIX UKA END: capture
+	
+    } else {
 		/*
 		 *  If the power of the incoming packet is smaller than the
 		 *  power of the packet currently being received by at least
                  *  the capture threshold, then we ignore the new packet.
 		 */
-		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
-			capture(p);
+        // BUGFIX UKA: capture
+        // Also support the new capture effect (can be activated and
+        // deactivated using the tcl variable newchipset_). In case of 
+        // activation a capture is also possible if the packet arriving
+        // later has a higher power of reception and does not reach the
+        // receiver within an interval of 4 to 10ms after start of reception
+        // of the first packet due to synchronization constraints.
+
+        // old implementation
+        
+        /*
+    		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
+	    		capture(p);
+		    } else {
+			    collision(p);
+		    }
+        */
+
+        // new implementation
+        
+        // store current time and capture threshold 
+        // (given in dB; transform to a factor)
+		double now = Scheduler::instance().clock();
+    	double Threshold = pow(10,p->txinfo_.CPThresh/10);
+        if (phymib_.get_newchipset() == false) {
+            // classic chipset, capture only possible if first packet is stronger
+	    	if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= Threshold) {
+				capture(p);
+			} else {
+				collision(p);
+			}
 		} else {
-			collision(p);
-		}
+		    // improved chipset
+			if (pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= Threshold){
+				capture(p);
+			} else if ((p->txinfo_.RxPr / pktRx_->txinfo_.RxPr >= Threshold )&&
+				   ((time_start_pktRx_ + 4e-6 > now)||(time_start_pktRx_ + 10e-6 < now))) {
+				   // in case that second packet is stronger, check if
+                   // sychronization is possible
+				capture(p);
+				time_start_pktRx_ = now;
+			} else {
+				collision(p);
+			}
+        }
+        // BUGFIX UKA END: capture
 	}
 }
 
@@ -1239,17 +1692,44 @@ Mac802_11::recv_timer()
          *  "arrives", then I would never have seen it and should
          *  do a silent discard without adjusting the NAV.
          */
-        if(tx_active_) {
-                Packet::free(pktRx_);
-                goto done;
-        }
+	// BUGFIX UKA: TxRxError
+    // Discard a packet that reaches the station during a transmission.
+    // The packet could technically not be received, however it is 
+    // possible in simulation. Therefore, such packets are marked
+    // special and just ignored after complete "reception".
+    
+    // old implementation
+    
+    //if(tx_active_) {
+    //        Packet::free(pktRx_);
+    //        goto done;
+    //}
+    
+    // new implementation
+	
+    if(tx_active_ || ch->error() == TX_RX_ERROR) {
+		Packet::free(pktRx_);
+		goto done;
+     	}
+	// BUGFIX UKA END: TxRxError
 
 	/*
 	 * Handle collisions.
 	 */
 	if(rx_state_ == MAC_COLL) {
 		discard(pktRx_, DROP_MAC_COLLISION);		
-		set_nav(usec(phymib_.getEIFS()));
+		// BUGFIX UKA: EIFS
+		// Start an EIFS period instead of the NAV timer by calling set_eifs
+
+        // old implementation
+        
+		// set_nav(usec(phymib_.getEIFS()));
+		
+        // new implementation
+        
+		set_eifs();
+		// BUGFIX UKA END: EIFS
+        
 		goto done;
 	}
 
@@ -1261,10 +1741,30 @@ Mac802_11::recv_timer()
 	 */
 	if( ch->error() ) {
 		Packet::free(pktRx_);
-		set_nav(usec(phymib_.getEIFS()));
+        // BUGFIX UKA: EIFS
+		// Start an EIFS period instead of the NAV timer by calling set_eifs
+
+        // old implementation
+        
+		// set_nav(usec(phymib_.getEIFS()));
+		
+        // new implementation
+        
+		set_eifs();
+		// BUGFIX UKA END: EIFS
+		
 		goto done;
 	}
 
+	// BUGFIX UKA: EIFS
+	// At this point it is sure that an error-free packet is received. 
+    // Remember this fact.
+	
+    // new implementation
+    
+    last_packet_correct_ = true;
+	// BUGFIX UKA END: EIFS
+
 	/*
 	 * IEEE 802.11 specs, section 9.2.5.6
 	 *	- update the NAV (Network Allocation Vector)
@@ -1273,11 +1773,12 @@ Mac802_11::recv_timer()
 		set_nav(mh->dh_duration);
 	}
 
-        /* tap out - */
-        if (tap_ && type == MAC_Type_Data &&
-            MAC_Subtype_Data == subtype ) {
+  /* tap out - */
+  if (tap_ && type == MAC_Type_Data && MAC_Subtype_Data == subtype ) 
+  {
 		if (!tap_filterown_ ||
-		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) {
+		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) 
+    {
 			tap_->tap(pktRx_);
 		}
 	}
@@ -1326,6 +1827,17 @@ Mac802_11::recv_timer()
 				subtype);
 			exit(1);
 		}
+
+        // BUGFIX UKA: Memory 
+        // The memory used by MAC Control packets should be freed if packets 
+        // are received and not used anymore This step was missing in the
+        // original implementation.
+        
+        // new implementation
+        
+        Packet::free(pktRx_);
+        // BUGFIX UKA END: Memory
+        
 		break;
 	case MAC_Type_Data:
 		switch(subtype) {
@@ -1482,8 +1994,35 @@ Mac802_11::recvDATA(Packet *p)
 				return;
 			}
 			sendACK(src);
-			if(mhSend_.busy() == 0)
-				tx_resume();
+            // BUGFIX UKA: transmission 
+            // An ACK packet should be sent in every case directly after a SIFS 
+            // period, even if there is a timeout pending 
+            // (See 9.2.8 in the Standard)
+            
+            // old implementation
+            
+            // if(mhSend_.busy() == 0)
+			//  tx_resume();
+            
+            // new implementation
+            
+            /*
+             *  Stop deferring - will be reset in tx_resume().
+             */
+            if(mhDefer_.busy()) mhDefer_.stop();
+
+            if (mhSend_.busy() == 0) {
+                tx_resume();
+            } 
+            else
+            {
+                // the station is waiting for a timeout. Stop waiting and 
+                // schedule a retransmit (done by sendHandler). tx_resume 
+                // to send the ACK is called from within sendHandler!
+                mhSend_.stop();
+                sendHandler();
+            }
+            // BUGFIX UKA END: transmission 
 		}
 	}
 	
@@ -1534,9 +2073,12 @@ Mac802_11::recvDATA(Packet *p)
 	 * the dh_3a field for the 'interested in the info'
 	 * receiver; we finally push the packet towards the
 	 * LL to be added back to my queue - accomplish this
-	 * by reversing the direction!*/
-
-	if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST)&& ((u_int32_t)ETHER_ADDR(dh->dh_3a) != ((u_int32_t)addr()))) {
+	 * by reversing the direction!
+   * */
+	if ( bss_id() == addr() 
+    && (u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST
+    && (u_int32_t)ETHER_ADDR(dh->dh_3a) != (u_int32_t)addr() ) 
+  {
 		struct hdr_cmn *ch = HDR_CMN(p);
 		u_int32_t dst = ETHER_ADDR(dh->dh_3a);
 		u_int32_t src = ETHER_ADDR(dh->dh_ta);
@@ -1580,6 +2122,23 @@ Mac802_11::recvACK(Packet *p)
 		ssrc_ = 0;
 	else
 		slrc_ = 0;
+
+        // TX feedback
+        u_int32_t *rcount;
+        hdr_cmn *ch = HDR_CMN(pktTx_);
+
+	if((u_int32_t) ch->size() <= macmib_.getRTSThreshold()) {
+          rcount = &ssrc_;
+        } else {
+          rcount = &slrc_;
+        }
+
+//        ch->size() -= phymib_.getHdrLen11();
+        ch->xmit_reason_ = XMIT_REASON_ACK;
+        ch->xmit_failure_(pktTx_->copy(),
+                          ch->xmit_failure_data_,
+                          *rcount);
+
 	rst_cw();
 	Packet::free(pktTx_); 
 	pktTx_ = 0;
@@ -1588,7 +2147,17 @@ Mac802_11::recvACK(Packet *p)
 	 * Backoff before sending again.
 	 */
 	assert(mhBackoff_.busy() == 0);
-	mhBackoff_.start(cw_, is_idle());
+    // BUGFIX UKA: EIFS
+    // changed method definition for backoff start causes changed call
+            
+    // old implementation
+             
+    // Backoff_.start(cw_, is_idle());
+            
+    // new implementation
+             
+    mhBackoff_.start(cw_, is_idle(), phymib_.getDIFS());
+    // BUGFIX UKA END: EIFS
 
 	tx_resume();
 
diff -rupN ns-2.29/mac/mac-802_11.h ns-2.29-click-scheduler/mac/mac-802_11.h
--- ns-2.29/mac/mac-802_11.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-802_11.h	2007-03-08 15:12:37.000000000 +0100
@@ -168,6 +168,17 @@ public:
 	inline u_int32_t getACKlen() {
 		return(getPLCPhdrLen() + sizeof(struct ack_frame));
 	}
+    
+    // BUGFIX UKA: capture
+    // returns true if the new implementation of the chipset is supported, 
+    // otherwise false
+    
+    // new implementation
+    
+    inline bool get_newchipset() {
+        return newchipset;
+    }
+    // BUGFIX UKA END: capture
 
  private:
 
@@ -181,6 +192,14 @@ public:
 	u_int32_t	PreambleLength;
 	u_int32_t	PLCPHeaderLength;
 	double		PLCPDataRate;
+    
+    // BUGFIX UKA: capture
+    // true if new chipset implementation is used, false otherwise
+    
+    // new implementation
+    
+    int newchipset;     
+    // BUGFIX UKA END: capture
 };
 
 
@@ -226,6 +245,17 @@ public:
 /* ======================================================================
    The actual 802.11 MAC class.
    ====================================================================== */
+
+// BUGFIX UKA: TxRxError
+// Define a specific value to mark packets that are not really received
+// because of the RxTxError
+
+// new implementation
+
+#define TX_RX_ERROR 5
+// BUGFIX UKA END: TxRxError
+
+
 class Mac802_11 : public Mac {
 	friend class DeferTimer;
 
@@ -276,7 +306,16 @@ private:
 	void	sendCTS(int dst, double duration);
 	void	sendACK(int dst);
 	void	sendDATA(Packet *p);
-	void	RetransmitRTS();
+
+	// BUGFIX UKA: EIFS
+	// definition of new method
+    
+    // new implementation
+    
+	void	StartRetransmitBackoff();
+	// BUGFIX UKA END: EIFS
+	
+    void	RetransmitRTS();
 	void	RetransmitDATA();
 
 	/*
@@ -320,6 +359,14 @@ private:
 	inline void setRxState(MacState newState);
 	inline void setTxState(MacState newState);
 
+	// BUGFIX UKA: EIFS
+	// declaration of methods to set and reset EIFS
+    
+    // new implementation
+    
+	inline void set_eifs();
+	inline void reset_eifs();
+	// BUGFIX UKA END: EIFS
 
 	inline void inc_cw() {
 		cw_ = (cw_ << 1) + 1;
@@ -377,7 +424,23 @@ private:
 	   ============================================================ */
 	double		nav_;		// Network Allocation Vector
 
-	MacState	rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
+	// BUGFIX UKA: EIFS
+	// variable that remembers if the last received packet was error-free
+    
+    // new implementation
+    
+	int		last_packet_correct_;
+	// BUGFIX UKA END: EIFS
+
+	// BUGFIX UKA: CAPTURE
+    // Variable saving the time of reception start
+    
+    // new implementation
+    
+	double time_start_pktRx_;
+	// BUGFIX UKA END: CAPTURE
+	
+    MacState	rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
 	MacState	tx_state_;	// outgoint state
 	int		tx_active_;	// transmitter is ACTIVE
 
diff -rupN ns-2.29/mac/mac-timers.cc ns-2.29-click-scheduler/mac/mac-timers.cc
--- ns-2.29/mac/mac-timers.cc	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-timers.cc	2007-03-08 15:12:37.000000000 +0100
@@ -221,8 +221,23 @@ BackoffTimer::handle(Event *)
 	mac->backoffHandler();
 }
 
+// BUGFIX UKA: EIFS
+// New additional parameter for this method, specifing the time the backoff 
+// process should wait before counting down the slots.
+// The value is of interest ONLY if medium is NOT busy at the moment 
+// of calling this method!
+
+// old implementation
+
+//void
+//BackoffTimer::start(int cw, int idle)
+
+// new implementation    
+
 void
-BackoffTimer::start(int cw, int idle)
+BackoffTimer::start(int cw, int idle, double time)
+// BUGFIX UKA END: EIFS
+
 {
 	Scheduler &s = Scheduler::instance();
 
@@ -239,14 +254,33 @@ BackoffTimer::start(int cw, int idle)
 #ifdef USE_SLOT_TIME
 	ROUND_TIME();
 #endif
-	difs_wait = 0.0;
 
+	// BUGFIX UKA: EIFS
+	// use the time parameter if necessary
+
+	// old implementation
+	
+    /*
+	difs_wait = 0.0;
 	if(idle == 0)
 		paused_ = 1;
 	else {
 		assert(rtime >= 0.0);
 		s.schedule(this, &intr, rtime);
 	}
+	*/
+
+	// new implementation
+	
+    if(idle == 0) {
+		difs_wait = 0.0;
+		paused_ = 1;
+    } else {
+		difs_wait = time;
+		assert(rtime >= 0.0);
+		s.schedule(this, &intr, rtime + difs_wait);
+	}
+	// BUGFIX UKA END: EIFS
 }
 
 
diff -rupN ns-2.29/mac/mac-timers.h ns-2.29-click-scheduler/mac/mac-timers.h
--- ns-2.29/mac/mac-timers.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mac/mac-timers.h	2007-03-08 15:12:37.000000000 +0100
@@ -73,11 +73,19 @@ protected:
 class BackoffTimer : public MacTimer {
 public:
 	BackoffTimer(Mac802_11 *m) : MacTimer(m), difs_wait(0.0) {}
-
-
-
-	void	start(int cw, int idle);
-	void	handle(Event *e);
+	// BUGFIX UKA: EIFS
+	// new declaration of start method with new parameter
+	
+	// old implementation
+    
+    // void	start(int cw, int idle);
+    
+    // new implementation
+	
+    void	start(int cw, int idle, double time);
+	// BUGFIX UKA END: EIFS
+	
+    void	handle(Event *e);
 	void	pause(void);
 	void	resume(double difs);
 private:
diff -rupN ns-2.29/mobile/dumb-agent.h ns-2.29-click-scheduler/mobile/dumb-agent.h
--- ns-2.29/mobile/dumb-agent.h	2005-10-20 06:45:22.000000000 +0200
+++ ns-2.29-click-scheduler/mobile/dumb-agent.h	2007-03-08 15:12:37.000000000 +0100
@@ -53,6 +53,7 @@
 #ifndef NS_DUMB_AGENT_H
 #define NS_DUMB_AGENT_H
 
+#include <stdarg.h>
 #include "agent.h"
 #include "ll.h"
 #include "trace.h"
diff -rupN ns-2.29/tcl/ex/nsclick-simple-hybrid.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-hybrid.tcl
--- ns-2.29/tcl/ex/nsclick-simple-hybrid.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-hybrid.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -189,7 +189,7 @@ for {set i 0} {$i < $wirelessnodecount }
     # "eth2" and so on.
     #
     $wireless_node_($i) add-interface $wireless_chan_ $prop_ $netll \
-	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+	    $wirelessmac $netifq 1 $wirelessphy $antenna
 
     #
     # Now configure the interface eth0
@@ -270,7 +270,7 @@ set bridge_node_ [$ns_ node]
 $bridge_node_ add-wired-interface $wired_chan_ $netll $wiredmac \
 	$netifq 1 $wiredphy
 $bridge_node_ add-interface $wireless_chan_ $prop_ $netll \
-	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+	    $wirelessmac $netifq 1 $wirelessphy $antenna
 
 $bridge_node_ random-motion 0
 $bridge_node_ topography $wtopo
@@ -361,12 +361,10 @@ $wired_node_(2) set Z_ 0
 #
 for {set i 0} {$i < $wirelessnodecount} {incr i} {
     $ns_ initial_node_pos $wireless_node_($i) 10
-    [$wireless_node_($i) entry] runclick
 }
 
 for {set i 0} {$i < $wirednodecount} {incr i} {
     $ns_ initial_node_pos $wired_node_($i) 10
-    [$wired_node_($i) entry] runclick
 }
 
 $ns_ initial_node_pos $bridge_node_ 10
diff -rupN ns-2.29/tcl/ex/nsclick-simple-lan.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-lan.tcl
--- ns-2.29/tcl/ex/nsclick-simple-lan.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-lan.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -249,7 +249,6 @@ $node_(3) set Z_ 0
 #
 for {set i 0} {$i < $nodecount} {incr i} {
     $ns_ initial_node_pos $node_($i) 20
-    [$node_($i) entry] runclick
 }
 
 #
diff -rupN ns-2.29/tcl/ex/nsclick-simple-wlan.tcl ns-2.29-click-scheduler/tcl/ex/nsclick-simple-wlan.tcl
--- ns-2.29/tcl/ex/nsclick-simple-wlan.tcl	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/tcl/ex/nsclick-simple-wlan.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -166,7 +166,7 @@ for {set i 0} {$i < $nodecount } {incr i
     # "eth2" and so on.
     #
     $node_($i) add-interface $chan_1_ $prop_ $netll $netmac \
-	$netifq 1 $netphy $antenna $wtopo
+	$netifq 1 $netphy $antenna
 
     #
     # Now configure the interface eth0
@@ -273,7 +273,6 @@ $node_(3) set Z_ 0
 #
 for {set i 0} {$i < $nodecount} {incr i} {
     $ns_ initial_node_pos $node_($i) 20
-    [$node_($i) entry] runclick
 }
 
 #
diff -rupN ns-2.29/tcl/lib/ns-autoconf.tcl ns-2.29-click-scheduler/tcl/lib/ns-autoconf.tcl
--- ns-2.29/tcl/lib/ns-autoconf.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.29-click-scheduler/tcl/lib/ns-autoconf.tcl	2007-03-08 15:12:37.000000000 +0100
@@ -0,0 +1,50 @@
+# -*-	Mode:tcl -*-
+#
+# Copyright (c) 1997 University of Southern California.
+# All rights reserved.                                            
+#                                                                
+# Redistribution and use in source and binary forms are permitted
+# provided that the above copyright notice and this paragraph are
+# duplicated in all such forms and that any documentation, advertising
+# materials, and other materials related to such distribution and use
+# acknowledge that the software was developed by the University of
+# Southern California, Information Sciences Institute.  The name of the
+# University may not be used to endorse or promote products derived from
+# this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
+# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+#
+
+# This file should contain variables changed only by autoconf.
+
+proc checkout_executable {exe_var best alternate text} {
+	global $exe_var
+	set $exe_var $best
+	if {"$best" == "" || ![file executable $best]} {
+		puts stderr $text
+		set $exe_var $alternate
+	}
+}
+
+#
+# Keep track of where the good perl is.
+#
+checkout_executable PERL "/usr/bin/perl" perl "\
+	When configured, ns found the right version of perl in\
+	/usr/bin/perl
+	but it doesn't seem to be there anymore, so\
+	ns will fall back on running the first perl in your path.\
+	The wrong version of perl may break the test suites.\
+	Reconfigure and rebuild ns if this is a problem.\
+"
+checkout_executable TCLSH "/usr/bin/tclsh8.4" tclsh "\
+	When configured, ns found the right version of tclsh in\
+	/usr/bin/tclsh8.4
+	but it doesn't seem to be there anymore, so\
+	ns will fall back on running the first tclsh in your path.\
+	The wrong version of tclsh may break the test suites.\
+	Reconfigure and rebuild ns if this is a problem.\
+"
diff -rupN ns-2.29/trace/cmu-trace.cc ns-2.29-click-scheduler/trace/cmu-trace.cc
--- ns-2.29/trace/cmu-trace.cc	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/trace/cmu-trace.cc	2007-03-08 15:12:37.000000000 +0100
@@ -64,7 +64,7 @@
 #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
 
 
-//#define LOG_POSITION
+#define LOG_POSITION
 
 //extern char* pt_names[];
 
@@ -540,7 +540,7 @@ CMUTrace::format_tcp(Packet *p, int offs
 }
 
 /* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
- * (with help from Florina Almenrez <florina@@it,uc3m,es>)
+ * (with help from Florina Almenrez <florina@@it,uc3m,es>)
  */
 void
 CMUTrace::format_sctp(Packet* p,int offset)
@@ -937,7 +937,7 @@ CMUTrace::nam_format(Packet *p, int offs
 	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
 	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
 	  "UNKN"
-	  ) : packet_info.name(ch->ptype())));
+	  ) : (packet_info.name(ch->ptype()) == NULL) ? "UNKN" : packet_info.name(ch->ptype()) ));
 	//</zheng: add for 802.15.4>
         int dst = Address::instance().get_nodeaddr(ih->daddr());
 
diff -rupN ns-2.29/trace/cmu-trace.h ns-2.29-click-scheduler/trace/cmu-trace.h
--- ns-2.29/trace/cmu-trace.h	2008-08-28 16:36:36.000000000 +0200
+++ ns-2.29-click-scheduler/trace/cmu-trace.h	2007-03-08 15:12:37.000000000 +0100
@@ -66,6 +66,12 @@
 
 #define DROP_END_OF_SIMULATION		"END"
 #define	DROP_MAC_COLLISION		"COL"
+
+// BUGFIX UKA: capture
+// packet drop in case of a packet capture
+#define DROP_MAC_CAPTURE        "CAP"
+// BUGFIX UKA END: capture
+
 #define DROP_MAC_DUPLICATE		"DUP"
 #define DROP_MAC_PACKET_ERROR		"ERR"
 #define DROP_MAC_RETRY_COUNT_EXCEEDED	"RET"
diff -rupN ns-2.29/wpan/p802_15_4mac.cc ns-2.29-click-scheduler/wpan/p802_15_4mac.cc
--- ns-2.29/wpan/p802_15_4mac.cc	2005-10-20 06:45:25.000000000 +0200
+++ ns-2.29-click-scheduler/wpan/p802_15_4mac.cc	2007-03-08 15:12:37.000000000 +0100
@@ -4859,7 +4859,7 @@ void Mac802_15_4::taskSuccess(char task,
 			{
 				ch->size() -= macHeaderLen(wph->MHR_FrmCtrl);
 				ch->xmit_reason_ = 1;
-				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_);
+				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_, -1);
 			}
 			if (callback_)	
 			{
@@ -4918,7 +4918,7 @@ void Mac802_15_4::taskFailed(char task,M
 				wph->setSN = true;		
 				ch->size() -= macHeaderLen(wph->MHR_FrmCtrl);
 				ch->xmit_reason_ = 0;
-				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_);
+				ch->xmit_failure_(p->refcopy(),ch->xmit_failure_data_, -1);
 			}
 			if (callback_			
 			&& (!dataWaitT->busy()))	
